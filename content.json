{"meta":{"title":"Tan's Blog","subtitle":"Have Fun","description":"Bioinformatics","author":"Zhengtang Tan","url":"https://tanzhengtang.github.io","root":"/"},"pages":[],"posts":[{"title":"Terecent Tao Analysis I Chapter2 & Exercise","slug":"Tao-analysis-Chapter2","date":"2023-02-28T16:00:00.000Z","updated":"2023-03-28T12:23:01.375Z","comments":true,"path":"2023/03/01/Tao-analysis-Chapter2/","link":"","permalink":"https://tanzhengtang.github.io/2023/03/01/Tao-analysis-Chapter2/","excerpt":"","text":"Chapter 2 Just to record my own thought and answer,if there has any error,please leave a message in the comment area. 2.1 The Peano Axioms 2.1.4 Proposition: 3 is a natural number Use Axiom 2.2 : If n is a natural number, then n++ is also a natural number. We know that 2 is natural number, and 3 is 2++,so 3 is natural number. 2.1.6 Proposition: 4 is not equal to 0 Use Axiom 2.3: 0 is not the successor of any natural number. 4 is 3++,so 4 is not equal to 0. 2.1.8 Proposition: 6 is not equal to 2 Use Axiom 2.4 : Different natural numbers must have different successors. 6 is 5++,and 2 is 1++, 5 is not equal to 1, so 6 is not equal to 2. 2.1.11 Proposition: A certain property P(n) is true for every natural number n Use Axiom 2.5 (Principle of mathematical induction): Let P(n) be any property pertaining to a natural number n. Suppose that P(0) is true, and suppose that whenever P(n) is true, P(n++) is also true. Then P(n) is true for every natural number n. According to the proposition, P(0) is true, if P(n) is true, according to axiom 2.5, we must to show P(n++) is true. Because n++ is natural number, according to the proposition again,P(n++) is true, so the proposition is true. 2.1.16 Proposition(Recursive definitions): Suppose for each natural number nnn, we have some function fnf_nfn​ : N→NN → NN→N from the natural numbers to the natural numbers. Let ccc be a natural number. Then we can assign a unique natural number ana_nan​ to each natural number nnn, such that a0=ca_0 = ca0​=c and an++a_{n++}an++​ = fn(an)f_n(a_n)fn​(an​) for each natural number nnn. The definition(informal) of function is a xxx for a only yyy. According to the proposition, ana_nan​ is also a one-to-one function of N to N. The proof is focus on ‘unique natural number’. If a0a_0a0​ is set to ccc, according to the proposition, other ana_nan​ can not be ccc, because axiom 2.3. If there exist ana_nan​ equal to a0a_0a0​,the nnn must be 0. Now we suppose ana_nan​ is true for this property, we can show an++a_{n++}an++​ is also true, because n++ is natural number, and n++ is not equal to n. Look at the official proof, I know my thought is not right. I don’t know if this is correct that thinking a0=ca_0 = ca0​=c is belong to fnf_nfn​. Please help me to understand the official anwser, I will be very grateful for it. 2.2 Addition 2.2.2 Lemma: For any natural number nnn, n+0=nn + 0 = nn+0=n Use Axiom 2.5 and Definition 2.2.1 (Addition of natural numbers) : Let m be a natural number. To add zero to m, we define 0+m:=m0 + m := m0+m:=m. Now suppose inductively that we have defined how to add n to m. Then we can add n++n++n++ to m by defining (n++)+m:=(n+m)++(n++) + m := (n + m)++(n++)+m:=(n+m)++. Let n=0n = 0n=0, n+0=0+0=0=nn + 0 = 0 + 0 = 0 = nn+0=0+0=0=n, assume n+0=nn + 0 = nn+0=n is true, show (n++)+0=(n+0)++=(n++)(n++) + 0 = (n + 0)++ = (n++)(n++)+0=(n+0)++=(n++) is also true. 2.2.3 Lemma: For any natural numbers nnn and mmm, n+(m++)=(n+m)++n + (m++) = (n + m)++n+(m++)=(n+m)++ Use Axiom 2.5 and Definition 2.2.1. Let n=0n = 0n=0, 0+(m++)=(m++)=(0+m)++0 + (m++) = (m++) = (0 + m)++0+(m++)=(m++)=(0+m)++, suppose n+(m++)=(n+m)++n + (m++) = (n+m)++n+(m++)=(n+m)++ is true. Show (n++)+(m++)=(n+m(++))++=((n+m)++)++=((n++)+m)++(n++) + (m++) = (n + m(++))++ = ((n + m)++)++ = ((n++) + m)++(n++)+(m++)=(n+m(++))++=((n+m)++)++=((n++)+m)++ is also true. 2.2.4 Proposition (Addition is commutative) : For any natural numbers nnn and mmm, n+m=m+nn+m=m+nn+m=m+n Use Axiom 2.5, Lemma 2.2.2 and Lemma 2.2.3 Let n=0n = 0n=0, n+m=0+m=m=m+0=m+nn + m = 0 + m = m = m + 0 = m + nn+m=0+m=m=m+0=m+n, suppose n+m=m+nn + m = m + nn+m=m+n is true. Show (n++)+m=(n+m)++=(m+n)++=m+(n++)(n++) + m = (n + m)++ = (m + n)++ = m + (n++)(n++)+m=(n+m)++=(m+n)++=m+(n++) is also true. 2.2.5 Proposition : (Addition is associative). For any natural numbers a,b,ca,b,ca,b,c, we have (a+b)+c=a+(b+c)(a+b)+c=a+(b+c)(a+b)+c=a+(b+c) Use Axiom 2.5, Lemma 2.2.2 and Lemma 2.2.3 Let a=0a = 0a=0,(a+b)+c=0+b+c=0+(b+c)=a+(b+c)(a + b) + c = 0 + b + c = 0 + (b + c) = a + (b + c)(a+b)+c=0+b+c=0+(b+c)=a+(b+c), suppose (a+b)+c=a+(b+c)(a + b) + c = a + (b + c)(a+b)+c=a+(b+c) is true, show ((a++)+b)+c=((a+b)++)+c=((a+b)+c)++=(a+(b+c))++=(a++)+(b+c)((a++) + b) + c = ((a + b)++) + c = ((a + b) + c)++ = (a + (b + c))++ = (a++) + (b + c)((a++)+b)+c=((a+b)++)+c=((a+b)+c)++=(a+(b+c))++=(a++)+(b+c) is also true. 2.2.6 Proposition : (Cancellation law). Let a,b,ca,b,ca,b,c be natural numbers such that a+b=a+ca+b=a+ca+b=a+c. Then we have b=cb=cb=c I think this proposition in a simple way: if a+b=b+ca + b = b + ca+b=b+c, then b=cb = cb=c. Use Axiom 2.5 and Axiom 2.4. Let a=0a = 0a=0, if a+b=b+ca + b = b + ca+b=b+c, then 0+b=0+c0 + b = 0 + c0+b=0+c, then b=cb = cb=c. Assume this property is true for aaa, show a++a++a++ is also true for this property. If (a++)+b=(a++)+c(a++) + b = (a++) + c(a++)+b=(a++)+c, then (a+b)++=(a+c)++(a + b)++ = (a + c)++(a+b)++=(a+c)++, according to axiom 2.4, different natural numbers must have different successors, so (a+b)(a + b)(a+b) must be equal to (a+c)(a + c)(a+c), according to the assumption, so for a++a++a++, also get the b=cb = cb=c. 2.2.8 Proposition : If aaa is positive and bbb is a natural number, then a+ba + ba+b is positive (and hence b+ab + ab+a is also, by Proposition 2.2.4) Use Definition 2.2.7 (Positive natural numbers) : A natural number n is said to be positive iff it is not equal to 0. Use Axiom 2.3. If aaa is positive,then aaa is not equal to 0, and b≥0b \\geq 0b≥0(informal), so a+ba + ba+b must be successor of natural number, and according to axiom 2.3, a+ba + ba+b can not be 0, then a+ba + ba+b is positive. 2.2.9 Corollary : If a and b are natural numbers such that a+b=0a + b = 0a+b=0, then a=0a=0a=0 and b=0b=0b=0 Use Proposition 2.2.8. If aaa not equal to 0 or bbb not equal to 000, use 2.2.8, then a+ba + ba+b is positive. So 2.2.9 is true. 2.2.10 Lemma : Let a be a positive number. Then there exists exactly one natural number b such that b++=ab++ = ab++=a Thought this lemma is that for every natural number has a positive successor number. Use Axiom 2.5. Let b=0b = 0b=0, 0++=10++ = 10++=1, and 111 is positive. Assume n++=(n++)n++ = (n++)n++=(n++), and n++n++n++ is positive. Show (n++)++(n++)++(n++)++is positvie. Because n++n++n++ is positive, so (n++)++(n++)++(n++)++ is natural number and not equal to 0. So (n++)++(n++)++(n++)++ is positive. 2.2.12 Proposition (Basic properties of order for natural numbers) (Order is reflexive) a ≥ a (Order is transitive) If a≥b and b≥c, then a≥c (Order is anti-symmetric) If a ≥ b and b ≥ a, then a = b (Addition preserves order) a≥b if and only if a+c≥b+c a&lt;b if and only if a++≤b a&lt;b if and only if b=a+d for some positive number d Use 2.2.11 Definition (Ordering of the natural numbers). Let n and m be natural numbers. We say that n is greater than or equal to m, and write n ≥ m or m ≤ n, iff we have n = m + a for some natural number a. We say that n is strictly greater than m, and write n &gt; m or m &lt; n, iff n ≥ m and nnotequaltomn not equal to mnnotequaltom a≥aa \\geq aa≥a, because a+0=aa + 0 = aa+0=a, and 0 is natural number. If a≥ba \\geq ba≥b and b≥cb \\geq cb≥c, then a≥ca \\geq ca≥c. Because b+m=ab + m = ab+m=a, c+n=bc + n = bc+n=b, use c+nc + nc+n to substitute bbb, have c+n+m=ac + n + m = ac+n+m=a, so a≥ca \\geq ca≥c. If a≥ba ≥ ba≥b and b≥ab ≥ ab≥a, then a=ba = ba=b. We have a+n=ba + n = ba+n=b and b+m=ab + m = ab+m=a, then a+n+m=a=a+0a + n + m = a = a + 0a+n+m=a=a+0, thought n+mn + mn+m is a natural number, use 2.2.6 proposition, then have n+m=0n + m = 0n+m=0, use 2.2.9 corollary, then n=m=0n = m = 0n=m=0, so we get a=ba = ba=b. a≥ba≥ba≥b if and only if a+c≥b+ca+c≥b+ca+c≥b+c. If b+n=ab + n = ab+n=a, we can have a+c=b+n+c=b+c+na + c = b + n + c = b + c + na+c=b+n+c=b+c+n, according to 2.2.11 definition, so a+c≥b+ca+c≥b+ca+c≥b+c. If we have a+c≥b+ca+c≥b+ca+c≥b+c, then a+c=b+c+n=b+n+ca + c = b + c + n = b + n + ca+c=b+c+n=b+n+c, think b+nb + nb+n is a number, use 2.2.6 proposition, so a=b+na = b + na=b+n, and then a≥ba≥ba≥b. a&lt;ba&lt;ba&lt;b if and only if a++≤ba++≤ba++≤b. If a&lt;ba &lt; ba&lt;b, according to 2.2.11 definition, we have a+n=ba + n = ba+n=b and nnn not equal to 0, use 2.2.10 lemma for nnn(nnn is positive), know there must be a natural number such that m++=nm++ = nm++=n, now we have a+(m++)=ba + (m++) = ba+(m++)=b, then (a++)+m=b(a++) + m = b(a++)+m=b, because mmm is a natural number, So a++≤ba++≤ba++≤b. If we have a++≤ba++≤ba++≤b, then (a++)+m=b(a++) + m = b(a++)+m=b, then a+(m++)=ba + (m++) = ba+(m++)=b, because m++m++m++ can not be 0, So a&lt;ba &lt; ba&lt;b. a&lt;ba&lt;ba&lt;b if and only if b=a+db=a+db=a+d for some positive number ddd. If a&lt;ba &lt; ba&lt;b, we have a+d=ba + d = ba+d=b and aaa not equal to bbb, assume ddd is 0, it will get a=ba = ba=b, this is a contradiction, so ddd not equal to 0, then ddd is positive number. If we have b=a+db=a+db=a+d for some positive number ddd,so a≤ba \\leq ba≤b, because ddd is positive, then aaa not equal to bbb, so a&lt;ba&lt;ba&lt;b is true. 2.2.13 Proposition : (Trichotomy of order for natural numbers). Let a and b be natural numbers. Then exactly one of the following statements is true: a&lt;b,a=ba&lt;b, a=ba&lt;b,a=b, or a&gt;ba&gt;ba&gt;b First, I want to prove that a,ba,ba,b really just have the three relations. Obviously, there has a=ba = ba=b. Consider if aaa not equal to bbb, use axiom 2.3 and 2.4, know that if a,ba,ba,b is different, then their predecrssor is also different. Recursively trace to the front,aaa and bbb trace same times ccc, will get 000 not equal to nnn,n∈Nn \\in Nn∈N, then n≥0n \\geq 0n≥0, and aaa not equal to bbb, so have n&gt;0n &gt; 0n&gt;0, and n+c&gt;0+cn + c &gt; 0 + cn+c&gt;0+c, so have a&gt;ba &gt; ba&gt;b or a&lt;ba &lt; ba&lt;b. Prove for every a,ba,ba,b, only have one relation in the three. If have a&gt;ba &gt; ba&gt;b or a&lt;ba &lt; ba&lt;b, use sixth conclusion of 2.2.12 prosition, get aaa not equal to bbb, beacuse axiom 2.3. And if have a=ba = ba=b, can not get a&lt;ba &lt; ba&lt;b or a&gt;ba &gt; ba&gt;b, because sixth conclusion of 2.2.12 prosition. 2.2.14 Proposition : (Strong principle of induction). Let m0m_0m0​ be a natural number, and let P(m)P(m)P(m) be a property pertaining to an number mmm. Suppose that for each m≥m0m ≥ m_0m≥m0​, we have the following implication: if P(m′)P(m^′)P(m′) is true for all natural numbers m0≤m′&lt;mm_0 ≤ m′ &lt; mm0​≤m′&lt;m, then P(m)P(m)P(m) is also true. (In particular, this means that P(m0)P(m_0)P(m0​) is true, since in this case the hypothesis is vacuous.) Then we can conclude that P(m)P(m)P(m) is true for all natural numbers m≥m0m ≥ m_0m≥m0​. Use axiom 2.5 Let Q(n)Q(n)Q(n) is such property for all nautral number n≥m0n \\geq m_0n≥m0​ that P(n)P(n)P(n) is true. If n≤m0n \\leq m_0n≤m0​, Q(n)Q(n)Q(n) is vacuous true, because the hypothesis is false. So if we set n=0n = 0n=0, Q(n)Q(n)Q(n) must be true, because m0≥0m_0 \\geq 0m0​≥0. Suppose Q(n)Q(n)Q(n) is true, consider Q(n+1)Q(n + 1)Q(n+1). If m0≥n+1m_0 \\geq n + 1m0​≥n+1, we have vacuous true, it is also true for Q(n)Q(n)Q(n). If n+1&gt;m0n + 1 &gt; m_0n+1&gt;m0​, we have m0≤n&lt;n+1m_0 \\leq n &lt; n+ 1m0​≤n&lt;n+1, because Q(n)Q(n)Q(n) is true, so Q(n+1)Q(n+1)Q(n+1) is also true. So this property is proved. Exercise Exercise 2.2.1 Prove Proposition 2.2.5 Exercise 2.2.2 Prove Lemma 2.2.10 Exercise 2.2.3 Prove Proposition 2.2.12 Exercise 2.2.4 Justify the three statements marked (why?) in the proof of Proposition 2.2.13. First why (When a=0a=0a=0 we have 0≤b0≤b0≤b for all bbb): this means for all natural number bbb we have b≥0b \\geq 0b≥0, use axiom 2.5, obviously when b=0b = 0b=0, this is true, suppose b=nb = nb=n is true, we can also get n+1&gt;n≥0n + 1 &gt; n \\geq 0n+1&gt;n≥0 is true, so b≥0b \\geq 0b≥0. Second why (If a&gt;ba&gt;ba&gt;b,then a++&gt;ba++&gt;ba++&gt;b): use a&gt;ba &gt; ba&gt;b, we have b+n=ab + n = ab+n=a, and nnn is positvie, and b+n+1=a+1=a++b + n + 1 = a + 1 = a++b+n+1=a+1=a++, this is b+1&lt;a++b + 1 &lt; a++b+1&lt;a++, and because b&lt;b+1b &lt; b + 1b&lt;b+1, so b&lt;a++b &lt; a++b&lt;a++. Third why (If a=ba=ba=b,then a++&gt;ba++&gt;ba++&gt;b): becasue a++=a+1=b+1a++ = a + 1 = b + 1a++=a+1=b+1, and 1 is positive, so a++&gt;ba++&gt;ba++&gt;b is true. Exercise 2.2.5 Prove Proposition 2.2.14 Exercise 2.2.6 Let nnn be a natural number, and let P(m)P(m)P(m) be a property pertaining to the natural numbers such that whenever P(m++)P(m++)P(m++) is true, then P(m)P(m)P(m) is true. Suppose that P(n)P(n)P(n) is also true. Prove that P(m)P(m)P(m) is true for all natural numbers m≤nm ≤ nm≤n; this is known as the principle of backwards induction. (Hint: apply induction to the variable nnn.) Proof: Let Q(n)Q(n)Q(n) is such property that P(m)P(m)P(m) is true for all natural numbers m≤nm \\leq nm≤n when P(n)P(n)P(n) is true. Let n=0n = 0n=0, so mmm must be 0, so P(m)=P(n)P(m) = P(n)P(m)=P(n) is true, then Q(n)Q(n)Q(n) is true when n=0n = 0n=0. Suppose Q(n)Q(n)Q(n) is true, consider Q(n++)Q(n++)Q(n++). So we have m≤n&lt;n++m \\leq n &lt; n++m≤n&lt;n++, because P(n++)P(n++)P(n++) is true, then P(n)P(n)P(n) is true, then P(m)P(m)P(m) is true (because suppose Q(n)Q(n)Q(n) is true), so Q(n++)Q(n++)Q(n++) is true.","categories":[{"name":"Math","slug":"Math","permalink":"https://tanzhengtang.github.io/categories/Math/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://tanzhengtang.github.io/tags/Math/"}]},{"title":"推送博客配置及笔记至github","slug":"pusblogct","date":"2023-02-18T13:08:49.000Z","updated":"2023-03-25T09:15:32.946Z","comments":true,"path":"2023/02/18/pusblogct/","link":"","permalink":"https://tanzhengtang.github.io/2023/02/18/pusblogct/","excerpt":"","text":"推送博客配置及笔记至github 内容来自知乎：https://zhuanlan.zhihu.com/p/187435941 此项笔记仅仅是为防丢。 若没有这样的措施，换台电脑就非常麻烦，什么都要重新弄。 原理 github.io站点只是展示master上的静态文件，我们可以再在这个仓库里创建新的分支，然后将本地的源代码推送至该分支即可。 运行hexo d时，生成的静态代码（在public文件夹中）会被自动push到远程仓库的maser分支。 操作 解决.gitgnore文件中的忽略项，一般情况下包含以下内容: .DS_Store, Thumbs.db, db.json, *.log, node_modules/, public/, .deploy*/ 去除掉db.json, Thumbs.db, node-modules/, 这3项包含hexo相关插件的重要信息，因此无需被忽略。 完成后执行git add * ; git commit -m &quot;first commit&quot; 若没有关联远程仓库，则git checkout -b source; git remote add github 远程仓库地址; git push -u github source 此时，我们最好去github上的远程仓库上，将远程仓库的主分支设置为source分支（默认为master分支）。（因为主分支不容易被删除。当我们意外删除主分支的时候，github会提醒我们这是主分支，这可以防止我们不小心删除source分支。并且，当我们在另一台电脑上从远程仓库clone时，本地仓库默认所在的分支是source分支。） 后记 一个仓库两个分支，默认情况下github pages服务展示的是master分支的静态代码，而笔记文件和配置的其他东西手动可推送至另一分支。","categories":[{"name":"Blog","slug":"Blog","permalink":"https://tanzhengtang.github.io/categories/Blog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://tanzhengtang.github.io/tags/Blog/"},{"name":"Web","slug":"Web","permalink":"https://tanzhengtang.github.io/tags/Web/"}]},{"title":"排序算法","slug":"sort","date":"2022-04-24T16:00:00.000Z","updated":"2023-03-25T09:15:32.947Z","comments":true,"path":"2022/04/25/sort/","link":"","permalink":"https://tanzhengtang.github.io/2022/04/25/sort/","excerpt":"","text":"排序 均为笔记，内容来自: https://oi-wiki.org/basic/sort-intro/ 归并排序 https://blog.csdn.net/k_koris/article/details/80508543 归并排序是一种稳定的排序算法。 归并排序的最优时间复杂度、平均时间复杂度和最坏时间复杂度均为O(nLogn)O(nLogn)O(nLogn)。 归并排序的空间复杂度为O(n)O(n)O(n)。 分而治之的思想 分解原问题为结构相同的子问题。 分解到某个容易求解的边界之后，进行递归求解。 将子问题的解合并成原问题的解。 递归 递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。 如： 12345int k(int a[],int i)&#123; if(i &lt;= 0)&#123; return 0; &#125; i = i - 1; return k(a,i) + 1;&#125; 重点:明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节。 步骤 考虑如下简单列表: [5,4,10,3] 那么按照分而治之的思想，我们可将其划分成两个小的列表，[5,4]以及[10,3]，对他们各自排好序后再次进行归并。 排好序后的[4,5]以及[3,10]，归并的时候是两个有序的列表，这儿我们可以采用有序列表的合并算法进行合并。实际上，[4,5]中的[5]以及[4]也是按照有序列表进行合并的。 如果按照上述的思维，我们可将一个很大的列表进行循环递增分割至最小的列表，然后按照有序列表进行合并。 用别人精炼的语言，即: 将数列划分为两部分； 递归地分别对两个子序列进行归并排序； 合并两个子序列。 将重点放在第3步上，合并两个有序的子序列。 12345678910111213141516171819202122232425262728293031//a = [4,5]//b = [3,10]int* merge_sort(int a[],int b[])&#123; int a_size = sizeof(a)/sizeof(int); int b_size = sizeof(b)/sizeof(int); int tmp_size = a_size + b_size; int tmp[tmp_size]; int s = 0; int a_s = 0; int b_s = 0; int a_e = a_size - 1; int b_e = b_size - 1; //从头开始将每个列表进行比较。 //类似插入排序，两个列表中小的元素插入新的数组前面。由于是都是有序的序列， //插入后只需将其中一个的指针往后移动，然后再进行比较。 while(a_s &lt;= a_e &amp;&amp; b_s &lt;= b_e)&#123; if(a[a_s] &gt; b[b_s])&#123; tmp[s++] = a[a_s++]; &#125; else&#123; tmp[s++] = b[b_s++]; &#125; &#125; while(a_s &lt;= a_e)&#123; tmp[s++] = a[a_s++]; &#125; while(b_s &lt;= b_e)&#123; tmp[s++] = b[b_s++]; &#125; return tmp;&#125; 上述的所花费的时间，即b_size + a_size，而这两个是由原先的列表所分割而成，即原列表的元素数量大小。 再来对1、2两步进行实现。 void merge(int a[],int t[],int start,int end)&#123; //终止条件即分割后的列表中最少存在1个元素。 if(start - end &lt;= 1)&#123;return;&#125; int mid = start + ((start - end) &gt;&gt; 1); //递归 merge(a,t,start,mid); merge(a,t,mid,end); //合并序列，所采用的思想同merge_sort中是一样的，但需进行一定改写， //因为此处是自身的分割序列，为了减小开销，我们并未真正的开辟了两个数组进行比较。 int s = start; int s1 = start; int ed1 = mid; int s2 = mid + 1; int ed2 = end; while(s1 &lt;= ed1 &amp;&amp; s2 &lt;= ed2)&#123; if(a[s1] &gt; a[s2])&#123; t[s++] = a[s2++]; &#125; else&#123; t[s++] = a[s1++]; &#125; &#125; while(s1 &lt;= ed1)&#123; t[s++] = a[s1++]; &#125; while(s2 &lt;= ed2)&#123; t[s++] = a[s2++]; &#125; &#125; 我们知道从各个子部分中间分割的话，所需的时间为LogNLogNLogN，而随着每一次递归，我们都进行了一次合并，乘以合并所需的时间即NlogNNlogNNlogN。 快速排序 内容待定","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://tanzhengtang.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://tanzhengtang.github.io/tags/Algorithm/"}]},{"title":"统计学习方法三要素","slug":"riskfunction","date":"2022-04-04T16:00:00.000Z","updated":"2023-03-25T09:15:32.946Z","comments":true,"path":"2022/04/05/riskfunction/","link":"","permalink":"https://tanzhengtang.github.io/2022/04/05/riskfunction/","excerpt":"","text":"统计学习方法三要素 课程内容： https://www.bilibili.com/video/BV1No4y1o7ac?p=4 纲要 三要素的定义 统计学习方法的三要素为模型、策略、算法。 模型是所有可能的条件概率分布或决策函数，用F\\mathcal{F}F表示。而所有的模型的集合称之为假设空间。 对于决策函数，实际上并不是很清楚。课程中，讲课者也只是说了它为非条件概率分布模型。 百度百科上，决策函数用于数据分类。例子：在二分类情况下，有决策函数y=f(x)y=f(x)y=f(x)，当y&gt;0y &gt; 0y&gt;0时，所取xxx实例集合便是一类，y&lt;0y&lt;0y&lt;0时的其他实例便是另一类。当然这些可以延伸到多分类问题。 如此看来的话，个人的理解便是：条件概率分布用于预测，而决策函数则是用于分类。 策略是用于选择最优模型的。 一般由损失函数来度量模型一次预测的好坏，记作L(Y,f(X))L(Y,f(X))L(Y,f(X)) 而度量所有情况下（平均意义下）的模型预测的好坏，则是Re=Ep[L(Y,f(X)]R_e = E_p[L(Y,f(X)]Re​=Ep​[L(Y,f(X)] 而LLL函数是由YYY和f(x)f(x)f(x)联合决定的，则可通过E(x)=∑i=1nP(xi)xiE(x)=\\sum_{i = 1}^n P(x_i)x_iE(x)=∑i=1n​P(xi​)xi​ 得到一般情况下的期望风险函数Re=∫XYL(y,f(x))P(x,y)dxdyR_e = \\int_{X Y} L(y,f(x))P(x,y)dxdyRe​=∫XY​L(y,f(x))P(x,y)dxdy 而往往P(x,y)P(x,y)P(x,y)我们是无法得知的，所以通常用经验风险来表示模型的平均损失：Remp(f)=1N∑i=1NL(yi,f(xi))R_{emp}(f) = \\cfrac{1}{N} \\sum_{i=1}^N L(y_i,f(x_i))Remp​(f)=N1​∑i=1N​L(yi​,f(xi​)) 损失函数顾名思义，便是预测值或者打分同实际值之间的差别。风险函数相当于把该损失函数应用于所有的实例来看这个模型好不好。 待定内容 待定内容","categories":[{"name":"Statistical Learning Methods","slug":"Statistical-Learning-Methods","permalink":"https://tanzhengtang.github.io/categories/Statistical-Learning-Methods/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://tanzhengtang.github.io/tags/Math/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://tanzhengtang.github.io/tags/Deep-Learning/"}]},{"title":"EdgeR查找差异表达基因(二)","slug":"EdgeR(2)","date":"2021-10-21T16:00:00.000Z","updated":"2023-03-25T09:15:32.933Z","comments":true,"path":"2021/10/22/EdgeR(2)/","link":"","permalink":"https://tanzhengtang.github.io/2021/10/22/EdgeR(2)/","excerpt":"","text":"EdgeR查找差异表达基因(二) 前言 第一篇有关于EdgeR处理差异基因的过程中有瑕疵的，这篇文章一是要提出上次过程中没写出的问题，二是要写出有关EdgeR原理方面的东西。 数据来源 癌症细胞：Encode上HepG2癌症细胞系total RNA-Seq的基因定量文件。 正常细胞：Encode上正常肝组织的total RNA-Seq的基因定量文件。 流程中的问题 基因定量信息 上次使用了Encode的基因定量文件中gene_id和expected_count两列组成EdgeR的输入数据文件。这样直接使用是粗糙的。 下载的ENSG数据中常常有小数点，小数点后面的表示的版本类型，在进行匹配时需要删除小数点后面的，一般情况下ENSG一共是15位，所有保留前15位字符就可以了. 读入数据: rep1=read.table(“./ENCFF944RFV.tsv”,header=T) rep2=read.table(“./ENCFF529HSE.tsv”,header=T) rep3=read.table(“./ENCFF396FZT.tsv”,header=T) rep4=read.table(“./ENCFF103FSL.tsv”,header=T) norm1=read.table(“~/Project/Normal_tissue/Liver/RNA/ENCFF780YUS.tsv”,header = T) norm2=read.table(“~/Project/Normal_tissue/Liver/RNA/ENCFF846SOK.tsv”,header = T) 处理gene_id: 以rep1为例: rep1 = rep1[grep(‘ENSG’,test$gene_id,invert = F),] rep1$gene_id = substr(rep1$gene_id,1,15) rep1 = aggregate(expected_count ~ gene_id , data = rep1,sum) 将其他的rep和norm作同样的处理 得到矩阵: count=data.frame(rep1$gene_id,rep1$expected_count,rep2$expected_count,rep3$expected_count,rep4$expected_count,norm1$expected_count,norm2$expected_count) colnames(count)=c(‘gene_id’,‘rep1’,‘rep2’,‘rep3’,‘rep4’,‘norm1’,‘norm2’) rownames(count)=count$gene_id count = count[,-c(1)] 原始矩阵count: 分组: 分组步骤同后面的流程息息相关。 它会影响过滤低表达基因和检验差异基因。 1.在过滤表达基因部分: The filtering should be based on the grouping factors or treatment factors that will be involved in the differential expression teststested for, rather than on blocking variables that are not of scientific interest in themselves. 2.在检验差异基因部分: (1) 单因子分组实验:The classic edgeR pipeline—&gt;edgeR uses the quantile-adjusted conditional maximum likelihood (qCML) method for experiments with single factor. (2) 多因子复杂分组:More complex experiments (glm functionality)—&gt;Generalized linear models (GLMs) are an extension of classical linear models to nonnormally distributed response data","categories":[{"name":"Bioinformatics","slug":"Bioinformatics","permalink":"https://tanzhengtang.github.io/categories/Bioinformatics/"}],"tags":[{"name":"RNA-Seq","slug":"RNA-Seq","permalink":"https://tanzhengtang.github.io/tags/RNA-Seq/"},{"name":"DE-Analysis","slug":"DE-Analysis","permalink":"https://tanzhengtang.github.io/tags/DE-Analysis/"}]},{"title":"clusterProfiler进行GO、KEGG以及相应的可视化","slug":"clusterProfiler","date":"2021-10-08T16:00:00.000Z","updated":"2023-03-25T09:15:32.942Z","comments":true,"path":"2021/10/09/clusterProfiler/","link":"","permalink":"https://tanzhengtang.github.io/2021/10/09/clusterProfiler/","excerpt":"","text":"clusterProfiler进行GO、KEGG以及相应的可视化 内容主要来源： https://guangchuangyu.github.io/softwaredocumentation/（官方使用文档) 数据来源 差异基因列表：NCI-H460癌症细胞同正常组织之间的差异基因。 承接自这篇笔记中:EdgeR查找差异表达基因 过程 GO分析 代码: ego &lt;- enrichGO(gene = idt,OrgDb = org.Hs.eg.db,keyType = 'ENSEMBL',ont = &quot;ALL&quot;,pAdjustMethod = &quot;BH&quot;,pvalueCutoff = 0.01,qvalueCutoff = 0.05,readable = T) gene是得到的差异基因列表. keyType指定基因ID的类型,默认为ENTREZID. OrgDb指定该物种对应的org包的名字. ont代表GO的3大类别，BP, CC, MF,而ALL是将该3类一起包含. pAdjustMethod指定多重假设检验矫正的方法. cufoff指定对应的阈值. readable=TRUE将基因ID转换为gene symbol. idt 差异基因列表: 这样就可以直接出图了。 dotplot(ego,showCategory = 10) barplot(ego,showCategory = 10) KEGG分析 在代码方面同GO分析差不多: kk=enrichKEGG(te$entrzid,organism=&quot;hsa&quot;, pvalueCutoff=0.05,pAdjustMethod=&quot;BH&quot;,qvalueCutoff=0.1) kk=setReadable(kk,OrgDb = org.Hs.eg.db,keyType = 'ENTREZID') 经尝试，KEGG分析似乎不支持ENSEMBL的ID，所以运行上面之前先转换成ENTRZID: en=mapIds(x = org.Hs.eg.db,keys = ed$symbol,keytype = &quot;SYMBOL&quot;,column = &quot;ENTREZID&quot;) ed$entrzid=en te=na.omit(ed) 出图： barplot(kk,ddrop=T,showCategory =10,title=&quot;KEGG Enrichment Pathways&quot;) 额外的pathview图： 内容来源: https://cloud.tencent.com/developer/article/1539928 genem=tee$logFC names(genem)=row.names(tee) pathview(gene.data = genem,pathway.id = '04514',species = 'hsa') pathway.id是信号通路的id，如04514意味着Cell adhesion molecules通路，画出的是该样本在某通路上的基因表达量变化。 gene.data是样本的表达量，这个可以是foldchange,也可以是cpm等等。 genem的行名须是ENTRZID. species是种类。 后续 1.原理（长期）。","categories":[{"name":"Bioinformatics","slug":"Bioinformatics","permalink":"https://tanzhengtang.github.io/categories/Bioinformatics/"}],"tags":[{"name":"RNA-Seq","slug":"RNA-Seq","permalink":"https://tanzhengtang.github.io/tags/RNA-Seq/"},{"name":"DE-Analysis","slug":"DE-Analysis","permalink":"https://tanzhengtang.github.io/tags/DE-Analysis/"}]},{"title":"插入排序","slug":"Algorithm/insertion-sort","date":"2021-10-08T16:00:00.000Z","updated":"2023-03-25T09:15:32.923Z","comments":true,"path":"2021/10/09/Algorithm/insertion-sort/","link":"","permalink":"https://tanzhengtang.github.io/2021/10/09/Algorithm/insertion-sort/","excerpt":"","text":"插入排序 内容主要来源： https://oi-wiki.org/basic/radix-sort/（OI Wiki） https://www.runoob.com/w3cnote/radix-sort.html（菜鸟教程） 简介 插入排序（英语：Insertion sort）是一种简单直观的排序算法。它的工作原理为将待排列元素划分为“已排序”和“未排序”两部分，每次从“未排序的”元素中选择一个插入到“已排序的”元素中的正确位置。 一个与插入排序相同的操作是打扑克牌时，从牌桌上抓一张牌，按牌面大小插到手牌后，再抓下一张牌。 时空复杂度 插入排序的最优时间复杂度为O(n)O(n)O(n)，在数列几乎有序时效率很高。 插入排序的最坏时间复杂度和平均时间复杂度都为O(n2)O(n2)O(n2)。 后续 1.原理（长期）。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://tanzhengtang.github.io/categories/Algorithm/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://tanzhengtang.github.io/tags/Math/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://tanzhengtang.github.io/tags/Algorithm/"}]},{"title":"基数排序","slug":"Algorithm/radix-sort","date":"2021-10-08T16:00:00.000Z","updated":"2023-03-25T09:15:32.924Z","comments":true,"path":"2021/10/09/Algorithm/radix-sort/","link":"","permalink":"https://tanzhengtang.github.io/2021/10/09/Algorithm/radix-sort/","excerpt":"","text":"基数排序 内容主要来源： https://oi-wiki.org/basic/radix-sort/（OI Wiki） https://www.runoob.com/w3cnote/radix-sort.html（菜鸟教程） 简介 基数排序（英语：Radix sort）是一种非比较型的排序算法，最早用于解决卡片排序的问题。 它的工作原理是将待排序的元素拆分为 个关键字（比较两个元素时，先比较第一关键字，如果相同再比较第二关键字……），然后先对第 关键字进行稳定排序，再对第 关键字进行稳定排序，再对第 关键字进行稳定排序……最后对第一关键字进行稳定排序，这样就完成了对整个待排序序列的稳定排序。 基数排序 vs 计数排序 vs 桶排序 基数排序有两种方法： 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异。 基数排序： 根据键值的每位数字来分配桶； 计数排序： 每个桶只存储单一键值； 桶排序： 每个桶存储一定范围的数值。 代码 后续 1.原理（长期）。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://tanzhengtang.github.io/categories/Algorithm/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://tanzhengtang.github.io/tags/Math/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://tanzhengtang.github.io/tags/Algorithm/"}]},{"title":"EdgeR查找差异表达基因","slug":"EdgeR","date":"2021-09-26T16:00:00.000Z","updated":"2023-03-25T09:15:32.934Z","comments":true,"path":"2021/09/27/EdgeR/","link":"","permalink":"https://tanzhengtang.github.io/2021/09/27/EdgeR/","excerpt":"","text":"EdgeR查找差异表达基因 内容主要来源： https://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf（官方使用文档) 数据来源 癌症细胞：Encode上NCI-H460癌症细胞系total RNA-Seq数据，因为Encode已经给出了基因定量的数据文件，故无需再重复跑一次产出定量文件的流程。 正常细胞：仍然来自于Encode,选用的正常肺组织的total RNA-Seq的基因定量文件。 过程 基因定量信息 Files need to contain two columns, one for the counts and one for a gene identifier. 所需的定量文件共两列，一列基因，一列基因的数量。从Encode上下载下来的文件内容是这样的: Note that edgeR is designed to work with actual read counts. We not recommend that predicted transcript abundances are input the edgeR in place of actual counts. 根据文档，要求我们使用初始的基因读数，这里使用了gene_id和expected_count两列组成EdgeR的输入数据文件。 读入初始数据: rep1=read.table(“./NCI-H460.totalRNA.geneQA.rep1.tsv”,header = TRUE) rep2=read.table(“./NCI-H460.totalRNA.geneQA.rep2.tsv”,header = TRUE) norm1=read.table(“./lung.toalRNA.geneQA.rep1.tsv”,header = TRUE) norm2=read.table(“./lung.toalRNA.geneQA.rep2.tsv”,header = TRUE) 提取所需两列: rep1=rep1[,1:5] rep1=rep1[,-c(2:4)] 其他rep2、norm1、norm2按照同样操作即可。 汇成总表： count=merge(norm1,norm2,by=“gene_id”) colnames(count)=c(“gene_id”,“nomr1”,“norm2”) count=merge(count,rep1,by=‘gene_id’) count=merge(count,rep2,by=‘gene_id’) colnames(count)=c(‘gene_Id’,‘norm1’,‘norm2’,‘rep1’,‘rep2’) row.names(count)=count$gene_Id count=count[,-c(1)] 转换成DGEList类型： 分组并转换： group=c(“norm”,“norm”,“cancer”,“cancer”) y=DGEList(counts=count,group = group) 如图上所示，rep1与rep2的lib.size的差异有点大。重新检查了下，确认并没有下载错误的文件，那么作为试水，继续进行下去吧。 过滤低表达基因： 从生物学的角度来看，一个基因必须在某种最低水平上表达，才有可能被翻译成蛋白质或具有生物学上的重要性。此外，这些计数的显著离散性也干扰了后面流程中使用的一些统计近似过程。 直接用filterByExpr进行过滤: keep=filterByExpr(y,group = group) y=y[keep,keep.lib.sizes=FALSE] keep应该是逻辑类型的向量，它其中代表的意义是哪些基因应该留下来，哪些基因该被筛选出去，故有第二步，需要根据keep对y做处理，才是真正意义上的筛选。 Normalization（标准化) 此时y中的样本之间仍然无法进行比较，样本的表达量是在相对不同的条件下测得的，而我们又恰恰需要观察样本之间本身的差异，需要将它们标准化。 EdgeR标准化没有将基因长度和GC含量作为主要因素，它把Sequencing depth和Effective library sizes作为标准化主要的方向。 直接进行标准化：y = calcNormFactors(y) norm.factors发生了变化。 We call the product of the original library size and the scaling factor the effective library size. The effective library size replaces the original library size in all downsteam analyses 在下面的分析中都是以这个effective library size为准。 effective library size = original library size * norm.factors 查找差异基因 经典的edgeR分析： edgeR uses the quantile-adjusted conditional maximum likelihood (qCML) method for experiments with single factor 该方法适用于单因子。 直接上命令: y = estimateDisp(y) et = exactTest(y) topTags(et) 显示的是norm组和cancer组之间的靠前显著基因。 如果想要更进一步进行筛选的话，可以按照et$table中的四个列进行筛选。 如：logFC &gt; 2 并且 p值 &lt; 0.05 ed = et$table[which(et$table$logFC &gt; 2 &amp; et$table$PValue &lt; 0.05),] 转换基因名 来源：https://github.com/twbattaglia/RNAseq-workflow library(org.Hs.eg.db) sy = mapIds(x = org.Hs.eg.db,keys = substr(row.names(ed),1,15),keytype = 'ENSEMBL',column = 'SYMBOL',multiVals = 'first') ed$symbol = sy 注意事项：转换的时候，ENSGXXXXXXXXXX.XX，需要去除小数点以及小数点后两位的数字。 后续 1.下游分析（GO、KEGG）以及可视化（热图，火山图）。 2.原理（长期）。","categories":[{"name":"Bioinformatics","slug":"Bioinformatics","permalink":"https://tanzhengtang.github.io/categories/Bioinformatics/"}],"tags":[{"name":"RNA-Seq","slug":"RNA-Seq","permalink":"https://tanzhengtang.github.io/tags/RNA-Seq/"},{"name":"DE-Analysis","slug":"DE-Analysis","permalink":"https://tanzhengtang.github.io/tags/DE-Analysis/"}]},{"title":"EdgeR原理探究","slug":"PrincipleOfEdgeR","date":"2021-09-26T16:00:00.000Z","updated":"2023-03-25T09:15:32.941Z","comments":true,"path":"2021/09/27/PrincipleOfEdgeR/","link":"","permalink":"https://tanzhengtang.github.io/2021/09/27/PrincipleOfEdgeR/","excerpt":"","text":"负二项分布模型 EdgeR包使用了负二项分布来对各个样本中的基因表达进行分析。 负二项分布描述的是第r次成功前失败的次数。一个成功概率为p的伯努利试验，不断重复，直至失败r次。此时成功的次数为一个随机变量，用XXX表示。称XXX服从二项分布，记作X∼NB(r,p)X \\sim NB(r,p)X∼NB(r,p) 为什么EdgeR作者将总的样本中的基因读数认作是服从负二项分布的呢？ 从手册中可知，原因有2个。一个是所谓的BCV值重要性比真实的基因丰度概率分布更重要。另一个是作者假定了基因丰度服从了伽马分布。 Biological coefficient of variation（BCV） 这个所谓的BCV，便是生物变异系数，按照手册中的定义，假设我们有iii个样本（有着多种分组），而对于单独一个样本而言，可测得总的基因GGG的读取数。这样我们也可知道第iii个样本中第ggg个的读取数占这个样本所有读取数的多少（百分数），记做πgi\\pi_{gi}πgi​，而将所有基因所占的部分加起来肯定等于1，则有∑g=1Gπgi=1\\sum_{g=1}^G \\pi_{gi} = 1∑g=1G​πgi​=1。 model EdgeR包采用了两种统计学方法，一种是所谓的精确统计，另一种是基于广义线性模型（glm）的统计。从官方文档来看，官方更为推崇glm。 这两种方法都采用了经验贝叶斯方法来估计特定基因的生物变异。","categories":[{"name":"Bioinformatics","slug":"Bioinformatics","permalink":"https://tanzhengtang.github.io/categories/Bioinformatics/"}],"tags":[{"name":"RNA-Seq","slug":"RNA-Seq","permalink":"https://tanzhengtang.github.io/tags/RNA-Seq/"},{"name":"DE-Analysis","slug":"DE-Analysis","permalink":"https://tanzhengtang.github.io/tags/DE-Analysis/"}]},{"title":"Mac下Hexo和Github免费搭建个人网站","slug":"BuildBlog","date":"2021-09-24T13:08:49.000Z","updated":"2023-03-25T09:15:32.924Z","comments":true,"path":"2021/09/24/BuildBlog/","link":"","permalink":"https://tanzhengtang.github.io/2021/09/24/BuildBlog/","excerpt":"","text":"前言: 1. 这篇文章写来试试效果，99%的内容来自于自网上的教程以及官网的文档，包括但不限于以下链接: https://zhuanlan.zhihu.com/p/111614119（主要来源，非常厉害的教程，windows可以直接按照此文进行搭建） https://hexo.io/zh-cn/docs/（hexo官方文档，中文版） http://nodejs.cn/(node.js的中文官网) https://docs.npmjs.com/（npm的官方文档） https://github.com/（github官网） 2. 整个过程以Mac系统进行说明。 正文： GitHub与Git GitHub的账号注册 进入官网(https://github.com/)后，用邮箱注册一个即可。 创建GitHub仓库 打开GitHub网页，登陆账号后，网页右上角有个➕的一个图标，点击它后再点击New repository。 这样会出来一个全新的页面，你需要在这个页面上的Repository name一栏填入xxxxxx.github.io。xxxxxxx就是你的GitHub账户名，整个必须完全一致才行。然后在Add a README file一栏进行打勾勾选，再点击Create repository进行创建。 创建完毕后，访问xxxxxx.github.io应该会出现类似于下面这种页面： Git的安装与设置 Git是一个分布式版本控制系统，本质上就是通过这个软件将所要存储的东西上传至GitHub账户中存储起来，当然也可以在一台全新的电脑上将存储在GitHub中的东西下载下来。推荐廖雪峰大佬的Git教程：https://www.liaoxuefeng.com/wiki/896043488029600。 安装： Mac中该软件应是自带。如果没有，请按照此链接https://git-scm.com/download/mac中的内容进行安装。 设置： 需要在终端对Git进行设置，输入命令git config --global user.name &quot;Your Name&quot;以及git config --global user.email &quot;email@example.com&quot; 第一个命令最后面是GitHub的用户名，第二个命令最后是GitHub注册时的邮箱。 设置完成后此时仍不能使用Git传输数据到GitHub上，因为传输需要加密。 继续在终端中输入命令ssh-keygen -t rsa -C &quot;youremail@example.com&quot;，邮件地址为注册账户时的邮件地址。输入该命令后，终端中会出现一些可输入选项，不用理会，一路回车即可。 上一个命令完成后，此时家目录中会生成名为.ssh的文件夹，输出该目录下的id_rsa.pub文件中的内容，它会是类似下面这种东西： 这是所需要的密匙，打开GitHub网站并登录，点击右上角的个人头像，并点击Settings。 在新出现的_Account settings_页面中点击SSH and GPG keys，再点击右上角绿色的new SSH key。 在key一栏中填入id_rsa.pub文件中的内容，title一栏中的内容可随意自取（一般来说是填办公地点）。内容填完后，点击绿色Add SSH key。 Hexo Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku，是搭建博客的首选框架。 实际上就是通过Hexo这个软件将你写的笔记自动地转换成前端页面，“漂亮”地把md文件展示出来。 安装 在安装Hexo之前，需要先安装Node.js软件。点击https://nodejs.org/en/，下载LTS版本的pkg文件进行安装。安装完成后此时在终端中可使用npm命令，输入npm install hexo-cli -g进行全局安装Hexo。如在这一步时出现了EACCES权限错误，可根据Hexo官方文档： 进入https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally，根据页面上的方法进行修复。 npm官方提供了两种修复方式，一是Reinstall npm with a node version manager；二是Manually change npm’s default directory。如采用第二种方式（如未能按此方法修复，可在https://hexo.io/zh-cn/docs/评论区中寻找类似情况并解决。）： 在终端中做完这5个步骤后，再使用npm install hexo-cli -g进行安装。 安装完成后，可使用npx hexo &lt;command&gt;调用Hexo。也可先使用echo PATH=$PATH:./node_modules/.bin &gt;&gt; ~/.profile命令将 Hexo 所在的目录下的 node_modules 添加到环境变量之中，这样可直接使用 hexo &lt;command&gt; 实际上在Mac下，把export PATH=~/.npm-global/bin:$PATH以及export PATH=&quot;$PATH:./node_modules/.bin&quot;放在~/.bashrc更为友好。若放在~/.profile中，仍需手动source ~/.profile才可生效。 设置 输入hexo -v可检查版本，测试是否安装成功。 家目录下创建名为blog的目录。在此目录下打开终端，依次输入hexo init以及npm install进行本地hexo的初始化。 依次使用hexo g（生成静态网页） hexo s（将网页部署到本地）,然后访问本地http://localhost:4000/，可查看测试网页。 hexo s等价于 hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。 hexo g 等价于 hexo generate #生成静态网页 (执行 $ hexo g 后会在站点根目录下生成public&gt;文件夹, hexo会将&quot;&lt;font /blog/source/&quot; 下面的.md后缀的文件编译为.html后缀的文件,存放在&quot;/blog/public/ &quot; 路径下) hexo d 等价于 hexo deploy #将本地数据部署到远端服务器(如github) hexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹. 停止测试网页，打开blog文件，打开其中的_config.yml文件，修改其中下面两段。 若需要将该blog文件上传至GitHub，还需安装扩展，输入npm i hexo-deployer-git进行安装。 输入hexo new post &quot;article title&quot;新建一篇md文章。在该文章中编写一些内容后，输入hexo g生成静态网页文件，再hexo d将blog文件推送至GitHub上。推送完毕后，如无意外，访问https://用户名.github.io，将会看到新的网页。 结语 1.Hexo面向md文件进行转化，所以还需学习如何编写md文件。 2.Hexo有很多开发好的网页主题，官网上就有许多推荐的主题，可自行取用。 3.搭建好的个人网站域名也可更改，谷歌一下即可解决。","categories":[{"name":"Blog","slug":"Blog","permalink":"https://tanzhengtang.github.io/categories/Blog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://tanzhengtang.github.io/tags/Blog/"}]},{"title":"Hexo博客插入图片","slug":"InsertImageinHexo","date":"2021-09-24T13:08:49.000Z","updated":"2023-03-25T09:15:32.940Z","comments":true,"path":"2021/09/24/InsertImageinHexo/","link":"","permalink":"https://tanzhengtang.github.io/2021/09/24/InsertImageinHexo/","excerpt":"","text":"Hexo博客插入图片问题 推送博客时遇到一个问题，图片无法顺利在网站中展现。 百度解决方法，内容来源：https://zhuanlan.zhihu.com/p/265077468 https://hexo.io/zh-cn/docs/asset-folders 在md文件中只需要![]()并在()中填写本地图片路径，图片即可插入。 解决办法： 在_congfig.yaml文件中将post_asset_folder: false改为post_asset_folder: true。 由于项目会生成新的文件目录，同时会解析Markdown中的图片路径，会导致一个问题。 如在一个文件目录下，博客名为1.md，相应的存在一个1文件夹存放图片image.jpg。 在Typora编辑器中，普通的md文件使用&#123;% asset_img \"image.jpg\" \"\" %&#125;能在编辑器中正常显示图片。 在hexo中，按理说应该是使用![](image.jpg)，但网页中却无法正常显示。 此时应该使用这样的方式来引入图片:&#123;% asset_img image.jpg 这是一张图片 %&#125; 2.解决&#123;% asset_img image.jpg 这是一张图片 %&#125; 这种难写的语法。npm install hexo-renderer-marked安装插件，并在_config.yaml中更改配置: post_asset_folder: true marked: prependRoot: true postAsset: true 3.如果采用![](image.jpg)的方式，此时md文件和相应图片处于同一目录下，但是直接上传仍然无法成功在网站上插入图片，而是需要将md文件拿到上级目录，像这样 如此的话，我们编写的时候可将md文件置于同一文件夹，编写完成时需将md文件拿到上级目录即可。","categories":[{"name":"Blog","slug":"Blog","permalink":"https://tanzhengtang.github.io/categories/Blog/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://tanzhengtang.github.io/tags/Blog/"}]}],"categories":[{"name":"Math","slug":"Math","permalink":"https://tanzhengtang.github.io/categories/Math/"},{"name":"Blog","slug":"Blog","permalink":"https://tanzhengtang.github.io/categories/Blog/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://tanzhengtang.github.io/categories/Algorithm/"},{"name":"Statistical Learning Methods","slug":"Statistical-Learning-Methods","permalink":"https://tanzhengtang.github.io/categories/Statistical-Learning-Methods/"},{"name":"Bioinformatics","slug":"Bioinformatics","permalink":"https://tanzhengtang.github.io/categories/Bioinformatics/"}],"tags":[{"name":"Math","slug":"Math","permalink":"https://tanzhengtang.github.io/tags/Math/"},{"name":"Blog","slug":"Blog","permalink":"https://tanzhengtang.github.io/tags/Blog/"},{"name":"Web","slug":"Web","permalink":"https://tanzhengtang.github.io/tags/Web/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://tanzhengtang.github.io/tags/Algorithm/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://tanzhengtang.github.io/tags/Deep-Learning/"},{"name":"RNA-Seq","slug":"RNA-Seq","permalink":"https://tanzhengtang.github.io/tags/RNA-Seq/"},{"name":"DE-Analysis","slug":"DE-Analysis","permalink":"https://tanzhengtang.github.io/tags/DE-Analysis/"}]}