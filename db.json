{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/pure/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/pure/source/about/index.md","path":"about/index.md","modified":0,"renderable":1},{"_id":"themes/pure/source/404/index.md","path":"404/index.md","modified":0,"renderable":1},{"_id":"themes/pure/source/books/index.md","path":"books/index.md","modified":0,"renderable":1},{"_id":"themes/pure/source/categories/index.md","path":"categories/index.md","modified":0,"renderable":1},{"_id":"themes/pure/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/pure/source/css/style.min.css","path":"css/style.min.css","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/README.md","path":"fonts/README.md","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.eot","path":"fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.svg","path":"fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.ttf","path":"fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/pure/source/fonts/iconfont.woff","path":"fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/pure/source/js/application.js","path":"js/application.js","modified":0,"renderable":1},{"_id":"themes/pure/source/js/application.min.js","path":"js/application.min.js","modified":0,"renderable":1},{"_id":"themes/pure/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/pure/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/pure/source/js/plugin.js","path":"js/plugin.js","modified":0,"renderable":1},{"_id":"themes/pure/source/js/plugin.js.map","path":"js/plugin.js.map","modified":0,"renderable":1},{"_id":"themes/pure/source/js/plugin.min.js","path":"js/plugin.min.js","modified":0,"renderable":1},{"_id":"themes/pure/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/pure/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/thumb-default.png","path":"images/thumb-default.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/xingqiu-qrcode.jpg","path":"images/xingqiu-qrcode.jpg","modified":0,"renderable":1},{"_id":"themes/pure/source/links/index.md","path":"links/index.md","modified":0,"renderable":1},{"_id":"themes/pure/source/repository/index.md","path":"repository/index.md","modified":0,"renderable":1},{"_id":"themes/pure/source/tags/index.md","path":"tags/index.md","modified":0,"renderable":1},{"_id":"themes/pure/source/images/donate/alipayimg.png","path":"images/donate/alipayimg.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/donate/wechatpayimg.png","path":"images/donate/wechatpayimg.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/favatar/chuangzaoshi-logo.png","path":"images/favatar/chuangzaoshi-logo.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/favatar/SzsFox-logo.png","path":"images/favatar/SzsFox-logo.png","modified":0,"renderable":1},{"_id":"themes/pure/source/images/favatar/idesign-logo.png","path":"images/favatar/idesign-logo.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/PrincipleOfEdgeR/.Rhistory","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1649150867212},{"_id":"source/.DS_Store","hash":"cc75fbdb977a72e3c33a32b977ec965c1597d5c5","modified":1676798483679},{"_id":"source/_posts/.DS_Store","hash":"fa9ff9f0e00be1ead87e6eb26e3e3b1675e57b5f","modified":1676798585206},{"_id":"source/_posts/BuildBlog.md","hash":"eed102ec9ddf3f366ba2d9630baffc27e0cdfb50","modified":1676733466814},{"_id":"source/_posts/EdgeR(2).md","hash":"ae91ba41d4687217c8f5fc1a4ef1eb981084b152","modified":1676733589638},{"_id":"source/_posts/EdgeR.md","hash":"36cb506542a08a7aab5528fcd0a4608280956127","modified":1676733627139},{"_id":"source/_posts/InsertImageinHexo.md","hash":"97ec9b64eb56e518bad3b561553b645cf3fdfa8e","modified":1676733547380},{"_id":"source/_posts/PrincipleOfEdgeR.md","hash":"20ada58b5a46c59cc12ebb171a6b0f411a7f4606","modified":1676733562117},{"_id":"source/_posts/clusterProfiler.md","hash":"932d62bf6f15618da372ea6dd2d89d81371da208","modified":1676733646409},{"_id":"source/_posts/riskfunction.md","hash":"24c8da7cdf45c83af6d8388662bd37588f69cbc5","modified":1676734154309},{"_id":"source/_posts/pusblogct.md","hash":"518cfc97d811d1a1660ff603ffba781c3a2762b9","modified":1676725797467},{"_id":"source/_posts/sort.md","hash":"79b45171170e949ff9afb5e052568b48746bf6c4","modified":1676726794240},{"_id":"source/_posts/Algorithm/.DS_Store","hash":"0be319250e49e06f9e0575e3eb705abf880632ad","modified":1649233216463},{"_id":"source/_posts/Algorithm/divide-and-conquer.cpp","hash":"2698d059efc1ee3a33f7235204ce9b2f3f2f134b","modified":1649233216463},{"_id":"source/_posts/Algorithm/insertion-sort.md","hash":"fb1227e41065bbed737eacd144d0b7f6b24842db","modified":1676798590694},{"_id":"source/_posts/Algorithm/radix-sort.cpp","hash":"4681f81d75a43423ef1a0fb21d245219e7e15255","modified":1649233216463},{"_id":"source/_posts/Algorithm/radix-sort.md","hash":"247b42fca37323404fff9bc005ae0f349bb0cdbb","modified":1676727068939},{"_id":"source/_posts/EdgeR/.DS_Store","hash":"66d984a5cd00989c9f39363f4a6cd701c8f74129","modified":1649249018431},{"_id":"source/_posts/EdgeR/1.png","hash":"a0811f1900ebdcb3c775a8b0e769640bd5794ba2","modified":1649233216471},{"_id":"source/_posts/EdgeR/4.png","hash":"41ca50472e198d8fa8b0268ecc616114224388dd","modified":1649233216473},{"_id":"source/_posts/EdgeR/5.png","hash":"bc7a64452163e1733f05b776a4bc6b4df0a9f0c5","modified":1649233216473},{"_id":"source/_posts/EdgeR/6.png","hash":"5f4c71d35d2cdb79cacbc0e0809a67c04e807294","modified":1649233216474},{"_id":"source/_posts/EdgeR/7.png","hash":"a457f1ae8e8a9e77e3535560ae63628fdd6b178c","modified":1649233216474},{"_id":"source/_posts/EdgeR/8.png","hash":"4e280f80a1e22f30902e33f873fd798125a7f602","modified":1649233216475},{"_id":"source/_posts/BuildBlog/.DS_Store","hash":"1d70ca36c98d6951cf6b94c3e55372a35a5cbcb4","modified":1676732992313},{"_id":"source/_posts/BuildBlog/blog1.png","hash":"5e644190c548f0dc0917f91532c16d6b8caa0ece","modified":1649233216464},{"_id":"source/_posts/BuildBlog/blog10.png","hash":"42960e228bb6de9d4a86db981f54fea626c4da63","modified":1649233216464},{"_id":"source/_posts/BuildBlog/blog12.png","hash":"7bd7017583c22817dc9cdcecb9fbdde035165975","modified":1649233216465},{"_id":"source/_posts/BuildBlog/blog13.png","hash":"d2daec27d84abb1f576be05a48122d22d79cd437","modified":1649233216466},{"_id":"source/_posts/BuildBlog/blog4.png","hash":"a6792fa87516c1f148e3f8d00cb849709a4c5281","modified":1649233216467},{"_id":"source/_posts/BuildBlog/blog3.jpeg","hash":"383a881a019841e4bf579216b7807bcffa99cfcb","modified":1649233216467},{"_id":"source/_posts/BuildBlog/blog6.png","hash":"0b89d715c023c7261885000d02070109b8c2cfe0","modified":1649233216468},{"_id":"source/_posts/BuildBlog/blog7.png","hash":"f16657f18329ad9068be6f07ce55a6817646c3a9","modified":1649233216469},{"_id":"source/_posts/EdgeR(2)/.DS_Store","hash":"0446bdf57e203f6e2a40cef21218870a7ef5cfc1","modified":1649249023454},{"_id":"source/_posts/InsertImageinHexo/.DS_Store","hash":"dd550aa4239984a5ef5cbc789f38c59c6c0e1f62","modified":1649249030582},{"_id":"source/_posts/InsertImageinHexo/insert.png","hash":"246d285677c24f160025e624eac30e17cc17b828","modified":1649233216477},{"_id":"source/_posts/PrincipleOfEdgeR/.DS_Store","hash":"68b0b010f6245b799ecfa6c7a3cf84a0dff00b23","modified":1649249035606},{"_id":"source/_posts/clusterProfiler/1.png","hash":"b22794c034a1e23431c4a7cd5c9d1c79242ab441","modified":1649233216479},{"_id":"source/_posts/clusterProfiler/.DS_Store","hash":"73f4dbb30653950c71354f5ceb3c28ad9b302aec","modified":1649249009178},{"_id":"source/_posts/clusterProfiler/2.png","hash":"b32f1288d183ed413259690875e8c48187c8def9","modified":1649233216479},{"_id":"source/_posts/clusterProfiler/3.png","hash":"15260285fe7f7285ff07a0963a5759875ae01453","modified":1649233216480},{"_id":"source/_posts/clusterProfiler/4.png","hash":"ac697beb42b329ae74e076fcd57b2790b303c056","modified":1649233216480},{"_id":"source/_posts/EdgeR/2.png","hash":"257f56c412dca0b33b78021b6eaaf04bc1d0eb98","modified":1649233216472},{"_id":"source/_posts/EdgeR/3.png","hash":"ecb6c9af5a4b27e5b78d2b23573985a7fa4b5e34","modified":1649233216472},{"_id":"source/_posts/BuildBlog/blog5.png","hash":"6db43b60634fd8dbceb350f5d5318c862ad81296","modified":1649233216468},{"_id":"source/_posts/BuildBlog/blog9.png","hash":"2a7afa11d8261d48e4e25bbddbd0efa72040436b","modified":1649233216470},{"_id":"source/_posts/EdgeR(2)/1.png","hash":"61368fddf885c791ca44c40301ea82b274b2bdf7","modified":1649233216470},{"_id":"source/_posts/PrincipleOfEdgeR/1.png","hash":"92871f911e370eca0181a6d19df25657ddd61c42","modified":1649233216478},{"_id":"source/_posts/PrincipleOfEdgeR/2.png","hash":"06a4fc86845f163815183610ada77d237c5c204b","modified":1649259502186},{"_id":"source/_posts/EdgeR/9.png","hash":"bf3db7a5860965690d6c6fe79684450f7a82fb4b","modified":1649233216476},{"_id":"source/_posts/BuildBlog/blog2.png","hash":"fd54a3e4ee0abcf43b90253988a5ec0028051af7","modified":1649233216467},{"_id":"source/_posts/BuildBlog/blog8.png","hash":"0bd5a927b4ed651ebe5323dc0fcffacb3ba87eff","modified":1649233216469},{"_id":"source/_posts/clusterProfiler/5.png","hash":"e65159879e1148d2632c9a3b025ce66e89e4a4b1","modified":1649233216482},{"_id":"themes/pure/.gitignore","hash":"dbb41a2f30c98cb9de173d82736c46266c901cda","modified":1647847126000},{"_id":"themes/pure/.DS_Store","hash":"136602c071333b865b2b9f2d95e8436310de676a","modified":1676799815889},{"_id":"themes/pure/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1676717851665},{"_id":"themes/pure/README.cn.md","hash":"ddf15a1feb7a2630210aae0528df3504fca23b5e","modified":1676717851666},{"_id":"themes/pure/README.md","hash":"5861cec81712af9197a210fd5212d007aad8b0de","modified":1676717851666},{"_id":"themes/pure/_config.yml.example","hash":"4714f87fdb6d4a6ea5ece84f4fe37f922337f14d","modified":1676717851666},{"_id":"themes/pure/_config.yml","hash":"f3d196fcba81e7ff509cbc6e820e49718b748612","modified":1676735972320},{"_id":"themes/pure/package.json","hash":"a61723eead5cae2c4d9f0f05cf40d2de7c286fee","modified":1676717851684},{"_id":"themes/pure/languages/en.yml","hash":"167ea0db98f4db156ea68c4644f64c0287ae2b6f","modified":1676717851668},{"_id":"themes/pure/languages/default.yml","hash":"167ea0db98f4db156ea68c4644f64c0287ae2b6f","modified":1676717851668},{"_id":"themes/pure/languages/zh-CN.yml","hash":"057ebc043f09449af9768791c89c86dfc2938365","modified":1676717851669},{"_id":"themes/pure/languages/zh-TW.yml","hash":"6d27c3114be539b8783ffce944f68b2e26a8c3b9","modified":1676717851669},{"_id":"themes/pure/layout/.DS_Store","hash":"751939c8fe5d3707f5b128224b9c930acf28a6a7","modified":1676736056372},{"_id":"themes/pure/layout/archive.ejs","hash":"0e9e67a82202ca3971be59579744d43ec6696bbf","modified":1676717851682},{"_id":"themes/pure/layout/about.ejs","hash":"4f5c769e183249b12eb9d3141432bc0039519730","modified":1676717851681},{"_id":"themes/pure/layout/books.ejs","hash":"6c64719cd7071b5319b01339aa524fdaab391385","modified":1676717851682},{"_id":"themes/pure/layout/categories.ejs","hash":"22a2bc1712dd9ba1a3027e875d636132d334fb00","modified":1676717851682},{"_id":"themes/pure/layout/index.ejs","hash":"07825d8d8b21eb7b694f5585567b9df5c5a91a60","modified":1676717851683},{"_id":"themes/pure/layout/category.ejs","hash":"3ca5651bbce7b0c280c906468f2eb18c2e55ebcb","modified":1676717851682},{"_id":"themes/pure/layout/layout.ejs","hash":"a29ab2e881954a252bfc0dc1a7eb5aa52768dd2a","modified":1676717851683},{"_id":"themes/pure/layout/links.ejs","hash":"77c5d1561e2c606c5b3bb39610133d84324074df","modified":1676717851683},{"_id":"themes/pure/layout/page.ejs","hash":"5c27475c176627e6e2e6a16172eb6980e56bcaff","modified":1676717851683},{"_id":"themes/pure/layout/repository.ejs","hash":"fe4b3e051a8b0debe9ee22c2cc2cc935d92ee23f","modified":1676717851683},{"_id":"themes/pure/layout/post.ejs","hash":"5c27475c176627e6e2e6a16172eb6980e56bcaff","modified":1676717851683},{"_id":"themes/pure/layout/tag.ejs","hash":"df60564c162f7ad3422f8959dfea19351857a7cd","modified":1676717851684},{"_id":"themes/pure/layout/tags.ejs","hash":"29f19a6ed10f8b1f069259a7aeaaacddcfaa2ed4","modified":1676717851684},{"_id":"themes/pure/scripts/thumbnail.js","hash":"e667a611f9baac270281b765832020d50bf8fb7f","modified":1676717851703},{"_id":"themes/pure/source/favicon.png","hash":"90a37cdad49474a897d769d13b50b6f1ccfdd72a","modified":1676722005823},{"_id":"themes/pure/.github/ISSUE_TEMPLATE/bug_report.md","hash":"83d211c67c12e8c1f6e9f796cfd0cecbf5160e15","modified":1647847126000},{"_id":"themes/pure/.github/ISSUE_TEMPLATE/custom.md","hash":"84208538d48505ee8e49812cb336eb9882e08dc7","modified":1647847126000},{"_id":"themes/pure/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":1647847126000},{"_id":"themes/pure/layout/_common/head.ejs","hash":"a48ef0fa22712b29ec044b9e5134461f3a21c10d","modified":1676717851670},{"_id":"themes/pure/layout/_common/footer.ejs","hash":"cdc48ec70d9202b947f2a9334234d038d7014a7d","modified":1676717851669},{"_id":"themes/pure/layout/_common/header.ejs","hash":"3d739d1e2b2991927c08ec222db123830a44a519","modified":1676717851670},{"_id":"themes/pure/layout/_common/script.ejs","hash":"0031114d2a58f8601c2869f78ceedc75a10be90d","modified":1676717851670},{"_id":"themes/pure/layout/_common/social.ejs","hash":"a35a2610e9da762df96587b76b51470507a88cad","modified":1676717851670},{"_id":"themes/pure/layout/_search/baidu.ejs","hash":"67aab280a3ea34429f086cc5c3de7de17727c567","modified":1676717851679},{"_id":"themes/pure/layout/_search/index-mobile.ejs","hash":"c726e234c0166da69fdfbd3dd613a5eaf4c80258","modified":1676717851680},{"_id":"themes/pure/layout/_search/index.ejs","hash":"f8d5a9c3f777250f5fb6512bba585307f784d5cd","modified":1676717851680},{"_id":"themes/pure/layout/_search/insight.ejs","hash":"4af3e92ef98bedba9680d45699cb04dde4640536","modified":1676717851680},{"_id":"themes/pure/layout/_search/swiftype.ejs","hash":"4baeca36e410181300ae7d47ba1fb4755bcfcff0","modified":1676717851680},{"_id":"themes/pure/layout/_widget/archive.ejs","hash":"af8ad7f62877764b75d5272d9d899fd6c8e3845c","modified":1676717851680},{"_id":"themes/pure/layout/_widget/board.ejs","hash":"acd27451be52703e670ce0b313f2da6fa24071e4","modified":1676717851681},{"_id":"themes/pure/layout/_widget/category.ejs","hash":"331b7642a0f58b9088b937436ab39076a4c5dd7e","modified":1676717851681},{"_id":"themes/pure/layout/_widget/recent_posts.ejs","hash":"8942d60311797a591ba2d157c5cdd23e85ceb694","modified":1676717851681},{"_id":"themes/pure/layout/_widget/tag.ejs","hash":"487628925da5fcac91463cdad3d9e55d071bd5ed","modified":1676717851681},{"_id":"themes/pure/layout/_widget/tagcloud.ejs","hash":"3291108e5411c48b2c5b3e17adace6ffa90d1c29","modified":1676717851681},{"_id":"themes/pure/layout/_partial/archive-book.ejs","hash":"977f97f3636947006ad738e502858c46d4cd5ec7","modified":1676717851670},{"_id":"themes/pure/layout/_partial/.DS_Store","hash":"0af4458db0eb004a5a78c033931219532df46e65","modified":1676735890882},{"_id":"themes/pure/layout/_partial/archive-category.ejs","hash":"9c364fd6b5172890784141802f5f466241d233fd","modified":1676717851670},{"_id":"themes/pure/layout/_partial/archive-link.ejs","hash":"fe4d9bf526d8176683cea89b8561ced571374db0","modified":1676717851671},{"_id":"themes/pure/layout/_partial/archive-list.ejs","hash":"1081974f182e8e1ce452d701b8f6575b6dc45b0c","modified":1676717851671},{"_id":"themes/pure/layout/_partial/archive-post.ejs","hash":"13039fec017332029122ef99901755fcecbfc8ea","modified":1676717851671},{"_id":"themes/pure/layout/_partial/archive-repository.ejs","hash":"3464682ae0359ba23034ac40e8153699c37fb7be","modified":1676717851671},{"_id":"themes/pure/layout/_partial/archive-tag.ejs","hash":"5de90244c3cedad531cccc03c40e5f9a3aef3c61","modified":1676717851671},{"_id":"themes/pure/layout/_partial/archive.ejs","hash":"4d6793f50d41fbd47dc50aa36b24d496006bba6c","modified":1676717851672},{"_id":"themes/pure/layout/_partial/article-about.ejs","hash":"7b80319daeb63401d1745b81cd9a6d1d21a4fb60","modified":1676717851672},{"_id":"themes/pure/layout/_partial/article.ejs","hash":"0f9b71de0087d1f777d92c5a0f3873971aec5a5b","modified":1676717851672},{"_id":"themes/pure/layout/_partial/item-post.ejs","hash":"2f3790257d6ad07fdad2043b27950842c9011daa","modified":1676717851672},{"_id":"themes/pure/source/.DS_Store","hash":"ac369b474aedddf48bbd25fc85d73595fc600dc8","modified":1676730874253},{"_id":"themes/pure/layout/_partial/pagination.ejs","hash":"c792537723b59f437967262c9575a20fac02e911","modified":1676717851672},{"_id":"themes/pure/layout/_partial/sidebar-about.ejs","hash":"46da1ee327b8af107335146bd8fc131eee6c9c4f","modified":1676717851675},{"_id":"themes/pure/layout/_partial/sidebar-toc.ejs","hash":"fa9e2041c4a6e03f566545db1385c5ae1a80f879","modified":1676717851675},{"_id":"themes/pure/layout/_partial/sidebar.ejs","hash":"2aa8a9f90838e7c105e75e6d3d03cbf860bb1239","modified":1676717851675},{"_id":"themes/pure/layout/_script/.DS_Store","hash":"70ad51483acf77f97bede58c6bf8e14c274001e5","modified":1676736023843},{"_id":"themes/pure/layout/_script/analytics.ejs","hash":"e756a81f8c20a187fb863b9689f2f1fa15e2f4e1","modified":1676717851678},{"_id":"themes/pure/layout/_script/comment.ejs","hash":"6f951510bab9dc15474b6664e0329defccf29a30","modified":1676717851678},{"_id":"themes/pure/layout/_script/douban.ejs","hash":"ee21c4e7ccac26ff2ab6d1d178447fd11fea4d7e","modified":1676717851678},{"_id":"themes/pure/layout/_script/fancybox.ejs","hash":"8f1be01e70a15b2c31ae57d8c6bce54622ebf8a7","modified":1676717851679},{"_id":"themes/pure/layout/_script/mathjax.ejs","hash":"f618393ab971b2faa80d541f2e6a553d9ace9816","modified":1676717851679},{"_id":"themes/pure/layout/_script/pv.ejs","hash":"fb9b5f16029f2ccef4b83cf4facfdcdd748b65b4","modified":1676717851679},{"_id":"themes/pure/layout/_script/repository.ejs","hash":"32f0ac36fa68d8786506957338e552661f2f809c","modified":1676717851679},{"_id":"themes/pure/layout/_script/search.ejs","hash":"7be33dc260ce788aa1a2cd3bd0386d95057533cb","modified":1676717851679},{"_id":"themes/pure/_source/404/index.md","hash":"8d493f624fdd29c8d0266767e56f343d549e16d8","modified":1676717851666},{"_id":"themes/pure/_source/_data/gallery.yml","hash":"e2b3fad87be3d1cfde1effa655d39678ee90907e","modified":1676717851666},{"_id":"themes/pure/_source/_data/links.yml","hash":"aa443a4508550820c77c2a4f6abff1d38ad85054","modified":1676717851667},{"_id":"themes/pure/_source/books/index.md","hash":"cf4163959c23244059cbbbc1c0fe379cc3b2cb73","modified":1676717851667},{"_id":"themes/pure/_source/about/index.md","hash":"9c95cabb533409d06daefc4295021ad199761efc","modified":1676717851667},{"_id":"themes/pure/_source/categories/index.md","hash":"5d2a4f103d27bebbe3eef1604649d0f5c6d86ac6","modified":1676717851667},{"_id":"themes/pure/_source/links/index.md","hash":"febcf87eb0ab3c5080578275d25f3970bba39625","modified":1676717851667},{"_id":"themes/pure/_source/repository/index.md","hash":"ed0e082c30f233dd5c140d188f1e4bce44bdbf79","modified":1676717851667},{"_id":"themes/pure/_source/tags/index.md","hash":"42e9c904ea63b0a7dd4033e2e8f153225bc5cda5","modified":1676717851668},{"_id":"themes/pure/source/_data/gallery.yml","hash":"e2b3fad87be3d1cfde1effa655d39678ee90907e","modified":1676717851666},{"_id":"themes/pure/source/_data/links.yml","hash":"aa443a4508550820c77c2a4f6abff1d38ad85054","modified":1676717851667},{"_id":"themes/pure/source/about/index.md","hash":"9c95cabb533409d06daefc4295021ad199761efc","modified":1676717851667},{"_id":"themes/pure/source/404/index.md","hash":"8d493f624fdd29c8d0266767e56f343d549e16d8","modified":1676717851666},{"_id":"themes/pure/source/books/index.md","hash":"cf4163959c23244059cbbbc1c0fe379cc3b2cb73","modified":1676717851667},{"_id":"themes/pure/source/categories/index.md","hash":"5d2a4f103d27bebbe3eef1604649d0f5c6d86ac6","modified":1676717851667},{"_id":"themes/pure/source/fonts/README.md","hash":"c5772b99ad81291fb137b330813f866bdceea0a3","modified":1676717851706},{"_id":"themes/pure/source/fonts/iconfont.eot","hash":"6819d9bb643bdeafc17bfecb0746ae641b018fdf","modified":1676717851706},{"_id":"themes/pure/source/fonts/iconfont.ttf","hash":"9b8837f9f79cf6ab794736301d0665345183a20c","modified":1676717851708},{"_id":"themes/pure/source/fonts/iconfont.woff","hash":"78d29194287b8885d25212048c4f787705212a6e","modified":1676717851708},{"_id":"themes/pure/source/js/application.js","hash":"46d1fb207ce5f0acb83803f927985dfcea86f9ef","modified":1676717851711},{"_id":"themes/pure/source/js/application.min.js","hash":"34d765e982c7d6360c37f82202d99f63ac40e408","modified":1676717851711},{"_id":"themes/pure/source/js/insight.js","hash":"298e8ca42517984bd26f34caa4c45560b0e909ad","modified":1676717851711},{"_id":"themes/pure/source/images/logo.png","hash":"43b506572db35681985c5b37189ca16baa21cdb2","modified":1676722996912},{"_id":"themes/pure/source/images/thumb-default.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1676717851710},{"_id":"themes/pure/source/images/.DS_Store","hash":"0836981b227a48692b5f97220fe01d1f917a0851","modified":1676723780651},{"_id":"themes/pure/source/links/index.md","hash":"febcf87eb0ab3c5080578275d25f3970bba39625","modified":1676717851667},{"_id":"themes/pure/source/repository/index.md","hash":"ed0e082c30f233dd5c140d188f1e4bce44bdbf79","modified":1676717851667},{"_id":"themes/pure/source/images/avatar.jpg","hash":"8248be372389964e12ab11642a803ce70849aa7e","modified":1676723780646},{"_id":"themes/pure/source/tags/index.md","hash":"42e9c904ea63b0a7dd4033e2e8f153225bc5cda5","modified":1676717851668},{"_id":"themes/pure/layout/_partial/post/category.ejs","hash":"fcee6b4aef8b6c4627831ff8dbb2d73478511426","modified":1676717851673},{"_id":"themes/pure/layout/_partial/post/copyright.ejs","hash":"0a99c99992fb1e97bf5a57e05179f5680d69dcc8","modified":1676717851673},{"_id":"themes/pure/layout/_partial/post/date.ejs","hash":"7d4979652998abf92a64bfae8157b70d6e514057","modified":1676717851673},{"_id":"themes/pure/layout/_partial/post/donate.ejs","hash":"a251dc34d660601a2e8b7d98b3bfe2b9023dbbce","modified":1676717851673},{"_id":"themes/pure/layout/_partial/post/comment.ejs","hash":"3c0da69fcea6ccfd97b82d50e740107a88eec5c4","modified":1676717851673},{"_id":"themes/pure/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1676717851674},{"_id":"themes/pure/layout/_partial/post/nav.ejs","hash":"fcbe3695ae9b164a4a2d27a66a6827dcf3ee76f1","modified":1676717851674},{"_id":"themes/pure/layout/_partial/post/pv.ejs","hash":"ec3ccf322432afc2761f860c5a3000ac34d46e4c","modified":1676717851674},{"_id":"themes/pure/layout/_partial/post/tag.ejs","hash":"39f53ead07f75c181a7ba93e586dd1b8171620f1","modified":1676717851674},{"_id":"themes/pure/layout/_partial/post/thumbnail.ejs","hash":"080d5c5f3e95accf51893a7092695fe32d34a087","modified":1676717851674},{"_id":"themes/pure/source/images/xingqiu-qrcode.jpg","hash":"ef2c2848dc79db6df7c752510651ed8ba57f2daf","modified":1676717851711},{"_id":"themes/pure/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1676717851674},{"_id":"themes/pure/layout/_partial/post/wordcount.ejs","hash":"bd06c4c8449ed96aabf655fe1ae3be1f0707b81e","modified":1676717851675},{"_id":"themes/pure/layout/_script/_analytics/google-analytics.ejs","hash":"54f1dc9375cbdb65464e0ac1b58847aa5e8bc6a5","modified":1676717851675},{"_id":"themes/pure/layout/_script/_analytics/baidu-analytics.ejs","hash":"f314be7860c1d5930f1600d010e3120ba5c85325","modified":1676717851675},{"_id":"themes/pure/layout/_script/_analytics/tencent-analytics.ejs","hash":"77defb41a1613a758ff5a6a5128c6107fc584190","modified":1676717851676},{"_id":"themes/pure/layout/_script/_comment/disqus.ejs","hash":"a051e3eddc75586e69131c29ab8c89d69626e0fd","modified":1676717851676},{"_id":"themes/pure/layout/_script/_comment/gitalk.ejs","hash":"de4c43d3056825c14283fe426b8cc677dea59617","modified":1676717851676},{"_id":"themes/pure/layout/_script/_comment/gitment.ejs","hash":"a64852076483395738a398deb4c10bdb0f3b7b71","modified":1676717851676},{"_id":"themes/pure/layout/_script/_comment/livere.ejs","hash":"5ab997d5ee4475d2f89f882fab4a52648dbe0e30","modified":1676717851676},{"_id":"themes/pure/layout/_script/_comment/valine.ejs","hash":"b9c2aae0bbc48404eb40dfebf46d9aaf14b511f0","modified":1676735989677},{"_id":"themes/pure/layout/_script/_comment/youyan.ejs","hash":"095649a173573d03b5845c2e331ec7be976b152a","modified":1676717851677},{"_id":"themes/pure/layout/_script/_repository/github.ejs","hash":"a4762135de6816c85156e85886f50fb32b0adc89","modified":1676717851677},{"_id":"themes/pure/layout/_script/_repository/gitee.ejs","hash":"0e1ecabe809f149ebe3ce3ac393f6e6155dd6780","modified":1676717851677},{"_id":"themes/pure/layout/_script/_repository/legacy.ejs","hash":"b5e5c666e89550abb5004e35c7ef165c6edab62d","modified":1676717851677},{"_id":"themes/pure/layout/_script/_search/insight.ejs","hash":"3543c11d060feaf9381b5d87564b01ffef0e0a59","modified":1676717851678},{"_id":"themes/pure/layout/_script/_search/baidu.ejs","hash":"9b60ffa2e2725a993e9cecfb81ddedd9b9361011","modified":1676717851678},{"_id":"themes/pure/source/images/donate/alipayimg.png","hash":"9562f23f2eb57841c65dc769b6cc43a2cf0efa94","modified":1676717851709},{"_id":"themes/pure/source/images/donate/wechatpayimg.png","hash":"c0844d9a633696cb00ae64fde06f0f924f63b596","modified":1676717851709},{"_id":"themes/pure/source/images/favatar/chuangzaoshi-logo.png","hash":"7fa5734072050952159a02d330bbc008b5a99122","modified":1676717851710},{"_id":"themes/pure/source/images/favatar/SzsFox-logo.png","hash":"d71fcc73b7bc2a439d8c7ba461137856d190bd76","modified":1676717851710},{"_id":"themes/pure/source/images/favatar/idesign-logo.png","hash":"6b150a2dbb9912b7a7662255c27e4d4baaecee71","modified":1676717851710},{"_id":"themes/pure/screenshot/pure-theme-black.png","hash":"10b40f398af7eb7e8ba2bf2f2a959d8779fc1fe1","modified":1676717851685},{"_id":"themes/pure/screenshot/pure-theme-green.png","hash":"12ec0c6033cb2762839fdf75434bbb4fbf946022","modified":1676717851687},{"_id":"themes/pure/screenshot/pure.png","hash":"8f4cfd8d7edfa4fbffdf375291302d9807f5cc1c","modified":1676717851689},{"_id":"themes/pure/screenshot/pure-theme-purple.png","hash":"9855d2eb0acd23370209354f232471df8f4f72e2","modified":1676717851688},{"_id":"themes/pure/screenshot/pure-theme-blue.png","hash":"6146890a68d5ea9d343c48d50151ddd5a2a1872c","modified":1676717851686},{"_id":"themes/pure/source/js/plugin.js","hash":"a8524d42b8621bfaa06602a163c6a1f82702b91d","modified":1676717851713},{"_id":"themes/pure/source/js/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1676717851712},{"_id":"themes/pure/source/js/plugin.min.js","hash":"07fe34638f9832702c5f81d8583c5e4e8b3d9659","modified":1676717851716},{"_id":"source/_posts/BuildBlog/blog11.png","hash":"b0ebc936b19dba02161025baae8d6d39ad2263c5","modified":1649233216465},{"_id":"themes/pure/source/css/style.css","hash":"a115348d8810a8d6b608ffc7bb02b915b3f48534","modified":1676717851704},{"_id":"themes/pure/source/css/style.min.css","hash":"1d23abc76726ebe042f7df4749f00f8f73338444","modified":1676717851705},{"_id":"themes/pure/source/js/plugin.js.map","hash":"1730c0cc660f863120aca0a439d7264e2e245fc5","modified":1676717851715},{"_id":"themes/pure/source/fonts/iconfont.svg","hash":"25929e6e74f7027acd1f6467a67e95b153bcd8d5","modified":1676717851707},{"_id":"themes/pure/screenshot/pure.psd","hash":"a31cea40b45bdc31f051fca2f1e2f4ecbaee1a94","modified":1676717851702},{"_id":"public/baidusitemap.xml","hash":"5c9dcc91fc4c50a74a144bc6eb6e1ae6bcf5d628","modified":1676799854027},{"_id":"public/atom.xml","hash":"82c55ac3cff7d66ae8c81165f5f621d7b0dfe275","modified":1676799854027},{"_id":"public/sitemap.xml","hash":"66ff4e408f0684ad1e59292040910ef16cbc05bb","modified":1676799854027},{"_id":"public/sitemap.txt","hash":"1b4d44e7a154917eee358083d6ac13cdd5e12fcd","modified":1676799854027},{"_id":"public/content.json","hash":"ad2350f57ba2a6c535cc9c1a266b28e34f5d1e9b","modified":1676799854027},{"_id":"public/2023/02/18/pusblogct/index.html","hash":"783d511c64991301a873ff11afbb89565a96b7ba","modified":1676799854027},{"_id":"public/2021/10/09/Algorithm/radix-sort/index.html","hash":"4583d71a2887543f2947634ea1b0e33829ff5dd3","modified":1676799854027},{"_id":"public/2021/10/09/Algorithm/insertion-sort/index.html","hash":"9349f718109986a4801c46a5c7f729133183d8f6","modified":1676799854027},{"_id":"public/2021/09/24/InsertImageinHexo/index.html","hash":"54e03456424ef10c84e267eb80f2ee0a2032644b","modified":1676799854027},{"_id":"public/archives/index.html","hash":"3de5050e94b98aed231d9a65c01a23736533f9ad","modified":1676799854027},{"_id":"public/archives/2021/index.html","hash":"6f285869f5376d9150c0ac66502d0ac6a00184c1","modified":1676799854027},{"_id":"public/archives/2021/09/index.html","hash":"74a8c31bf85eec58ef36e1f184377e2a6bc9a4b7","modified":1676799854027},{"_id":"public/archives/2021/10/index.html","hash":"13837d6b8028110604ccd83ab63f1d27f95e7838","modified":1676799854027},{"_id":"public/archives/2022/index.html","hash":"6528f252e7e85bfa833dd24d2cac445ef2a670da","modified":1676799854027},{"_id":"public/archives/2022/04/index.html","hash":"470f0c232ab7cc1a69784076793d64c0583e2337","modified":1676799854027},{"_id":"public/archives/2023/index.html","hash":"6a22df67927e9d649e52e5becc7ba5ccb149f441","modified":1676799854027},{"_id":"public/archives/2023/02/index.html","hash":"44ddf21199b1b79577cb11bfcbdc167fd790861f","modified":1676799854027},{"_id":"public/categories/Blog/index.html","hash":"a6fbe8ad17a0cb1557582592c85779aadf3f7ef3","modified":1676799854027},{"_id":"public/categories/Bioinformatics/index.html","hash":"293125743beab44fc13ecf1221e1524aa0996aaa","modified":1676799854027},{"_id":"public/categories/Statistical-Learning-Methods/index.html","hash":"868f83aeda403cbb1cb43c095ee058f6cdd89572","modified":1676799854027},{"_id":"public/categories/Algorithm/index.html","hash":"106ebfc1b492bdfc6ba40fb06d6e717df5d33afd","modified":1676799854027},{"_id":"public/tags/Blog/index.html","hash":"e6e65e4db75355919eb7b06ae18e75a8502e75ec","modified":1676799854027},{"_id":"public/tags/RNA-Seq/index.html","hash":"af31c1ace1faaa3c5d130944cabeec06e2b34e94","modified":1676799854027},{"_id":"public/tags/DE-Analysis/index.html","hash":"145330dba547b7a5043032c040fc545e68c06151","modified":1676799854027},{"_id":"public/tags/Web/index.html","hash":"d38d8070359b9a86e865cedc28ac859b7160749f","modified":1676799854027},{"_id":"public/tags/Deep-Learning/index.html","hash":"1da97b4823a41c2a476b5892482dccc774a9b27e","modified":1676799854027},{"_id":"public/tags/Math/index.html","hash":"3f6c3918210e0535735d44a83720593d7a8966b5","modified":1676799854027},{"_id":"public/tags/Algorithm/index.html","hash":"a67b34079f13ed246681dc7a6d128a2810c39b7f","modified":1676799854027},{"_id":"public/2022/04/25/sort/index.html","hash":"0ab5e1a6997a7631497e59b58f8b87d46fb4661b","modified":1676799854027},{"_id":"public/2022/04/05/riskfunction/index.html","hash":"9c90527547651af38fb037d651a6bf5e4d2dee10","modified":1676799854027},{"_id":"public/2021/10/22/EdgeR(2)/index.html","hash":"7f11b67babfb353f50b4d3ae6f263361e0827428","modified":1676799854027},{"_id":"public/2021/10/09/clusterProfiler/index.html","hash":"fe313223ff12701aad93ce55b55760c6c8491d09","modified":1676799854027},{"_id":"public/2021/09/27/EdgeR/index.html","hash":"d5ae0f9a0a73b0211ae3bd5fec70502040846302","modified":1676799854027},{"_id":"public/2021/09/27/PrincipleOfEdgeR/index.html","hash":"f339266d0d76295200bec0c00f6ea7570b8833e9","modified":1676799854027},{"_id":"public/2021/09/24/BuildBlog/index.html","hash":"c631c76e5c02101385390604597ed99cc3b45daf","modified":1676799854027},{"_id":"public/index.html","hash":"c2f98aafae6dd1f1e0ff4419153d47db6f1885bb","modified":1676799854027},{"_id":"public/fonts/iconfont.ttf","hash":"9b8837f9f79cf6ab794736301d0665345183a20c","modified":1676799854027},{"_id":"public/favicon.png","hash":"90a37cdad49474a897d769d13b50b6f1ccfdd72a","modified":1676799854027},{"_id":"public/fonts/iconfont.eot","hash":"6819d9bb643bdeafc17bfecb0746ae641b018fdf","modified":1676799854027},{"_id":"public/fonts/iconfont.woff","hash":"78d29194287b8885d25212048c4f787705212a6e","modified":1676799854027},{"_id":"public/images/logo.png","hash":"43b506572db35681985c5b37189ca16baa21cdb2","modified":1676799854027},{"_id":"public/images/thumb-default.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1676799854027},{"_id":"public/images/avatar.jpg","hash":"8248be372389964e12ab11642a803ce70849aa7e","modified":1676799854027},{"_id":"public/images/donate/wechatpayimg.png","hash":"c0844d9a633696cb00ae64fde06f0f924f63b596","modified":1676799854027},{"_id":"public/images/xingqiu-qrcode.jpg","hash":"ef2c2848dc79db6df7c752510651ed8ba57f2daf","modified":1676799854027},{"_id":"public/images/donate/alipayimg.png","hash":"9562f23f2eb57841c65dc769b6cc43a2cf0efa94","modified":1676799854027},{"_id":"public/images/favatar/chuangzaoshi-logo.png","hash":"7fa5734072050952159a02d330bbc008b5a99122","modified":1676799854027},{"_id":"public/images/favatar/SzsFox-logo.png","hash":"d71fcc73b7bc2a439d8c7ba461137856d190bd76","modified":1676799854027},{"_id":"public/images/favatar/idesign-logo.png","hash":"6b150a2dbb9912b7a7662255c27e4d4baaecee71","modified":1676799854027},{"_id":"public/2021/09/24/BuildBlog/blog1.png","hash":"5e644190c548f0dc0917f91532c16d6b8caa0ece","modified":1676799854027},{"_id":"public/2021/09/24/BuildBlog/blog10.png","hash":"42960e228bb6de9d4a86db981f54fea626c4da63","modified":1676799854027},{"_id":"public/2021/09/24/BuildBlog/blog12.png","hash":"7bd7017583c22817dc9cdcecb9fbdde035165975","modified":1676799854027},{"_id":"public/2021/09/24/BuildBlog/blog13.png","hash":"d2daec27d84abb1f576be05a48122d22d79cd437","modified":1676799854027},{"_id":"public/2021/09/24/BuildBlog/blog4.png","hash":"a6792fa87516c1f148e3f8d00cb849709a4c5281","modified":1676799854027},{"_id":"public/2021/09/24/BuildBlog/blog3.jpeg","hash":"383a881a019841e4bf579216b7807bcffa99cfcb","modified":1676799854027},{"_id":"public/2021/09/24/BuildBlog/blog7.png","hash":"f16657f18329ad9068be6f07ce55a6817646c3a9","modified":1676799854027},{"_id":"public/2021/09/24/BuildBlog/blog6.png","hash":"0b89d715c023c7261885000d02070109b8c2cfe0","modified":1676799854027},{"_id":"public/2021/09/27/EdgeR/1.png","hash":"a0811f1900ebdcb3c775a8b0e769640bd5794ba2","modified":1676799854027},{"_id":"public/2021/09/27/EdgeR/4.png","hash":"41ca50472e198d8fa8b0268ecc616114224388dd","modified":1676799854027},{"_id":"public/2021/09/27/EdgeR/7.png","hash":"a457f1ae8e8a9e77e3535560ae63628fdd6b178c","modified":1676799854027},{"_id":"public/2021/09/27/EdgeR/5.png","hash":"bc7a64452163e1733f05b776a4bc6b4df0a9f0c5","modified":1676799854027},{"_id":"public/2021/09/27/EdgeR/6.png","hash":"5f4c71d35d2cdb79cacbc0e0809a67c04e807294","modified":1676799854027},{"_id":"public/2021/09/27/EdgeR/8.png","hash":"4e280f80a1e22f30902e33f873fd798125a7f602","modified":1676799854027},{"_id":"public/2021/09/24/InsertImageinHexo/insert.png","hash":"246d285677c24f160025e624eac30e17cc17b828","modified":1676799854027},{"_id":"public/2021/10/09/clusterProfiler/1.png","hash":"b22794c034a1e23431c4a7cd5c9d1c79242ab441","modified":1676799854027},{"_id":"public/2021/10/09/clusterProfiler/4.png","hash":"ac697beb42b329ae74e076fcd57b2790b303c056","modified":1676799854027},{"_id":"public/2021/10/09/clusterProfiler/3.png","hash":"15260285fe7f7285ff07a0963a5759875ae01453","modified":1676799854027},{"_id":"public/2021/10/09/clusterProfiler/2.png","hash":"b32f1288d183ed413259690875e8c48187c8def9","modified":1676799854027},{"_id":"public/2021/10/22/EdgeR(2)/1.png","hash":"61368fddf885c791ca44c40301ea82b274b2bdf7","modified":1676799854027},{"_id":"public/2021/09/24/BuildBlog/blog5.png","hash":"6db43b60634fd8dbceb350f5d5318c862ad81296","modified":1676799854027},{"_id":"public/2021/09/24/BuildBlog/blog9.png","hash":"2a7afa11d8261d48e4e25bbddbd0efa72040436b","modified":1676799854027},{"_id":"public/2021/09/27/EdgeR/2.png","hash":"257f56c412dca0b33b78021b6eaaf04bc1d0eb98","modified":1676799854027},{"_id":"public/2021/09/27/EdgeR/3.png","hash":"ecb6c9af5a4b27e5b78d2b23573985a7fa4b5e34","modified":1676799854027},{"_id":"public/2021/09/27/PrincipleOfEdgeR/2.png","hash":"06a4fc86845f163815183610ada77d237c5c204b","modified":1676799854027},{"_id":"public/2021/09/27/PrincipleOfEdgeR/1.png","hash":"92871f911e370eca0181a6d19df25657ddd61c42","modified":1676799854027},{"_id":"public/about/index.html","hash":"04cc167364ad9ad8d58a06184ad24964b168c6c3","modified":1676799854027},{"_id":"public/404/index.html","hash":"6740d05ad5fb1eba4561174d0eef4a6d380098f5","modified":1676799854027},{"_id":"public/books/index.html","hash":"60f583e1d1423a7f1327656b8104fe43f12ffa70","modified":1676799854027},{"_id":"public/categories/index.html","hash":"48394e6f653665c3bcc79122af173d61cb1e8b09","modified":1676799854027},{"_id":"public/fonts/README.html","hash":"26a13286f808d3ef09314df865be3049eef3906f","modified":1676799854027},{"_id":"public/js/application.min.js","hash":"34d765e982c7d6360c37f82202d99f63ac40e408","modified":1676799854027},{"_id":"public/js/application.js","hash":"46d1fb207ce5f0acb83803f927985dfcea86f9ef","modified":1676799854027},{"_id":"public/js/insight.js","hash":"298e8ca42517984bd26f34caa4c45560b0e909ad","modified":1676799854027},{"_id":"public/links/index.html","hash":"6f9cacf914d09040d68e0d14f97e864f0295221b","modified":1676799854027},{"_id":"public/repository/index.html","hash":"3108f324cafd97a728a974c69f0cbbd306ffac5a","modified":1676799854027},{"_id":"public/tags/index.html","hash":"441138f7e3b77072df339c401eb005346342208f","modified":1676799854027},{"_id":"public/css/style.css","hash":"a115348d8810a8d6b608ffc7bb02b915b3f48534","modified":1676799854027},{"_id":"public/css/style.min.css","hash":"1d23abc76726ebe042f7df4749f00f8f73338444","modified":1676799854027},{"_id":"public/js/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1676799854027},{"_id":"public/js/plugin.min.js","hash":"07fe34638f9832702c5f81d8583c5e4e8b3d9659","modified":1676799854027},{"_id":"public/js/plugin.js","hash":"a8524d42b8621bfaa06602a163c6a1f82702b91d","modified":1676799854027},{"_id":"public/fonts/iconfont.svg","hash":"25929e6e74f7027acd1f6467a67e95b153bcd8d5","modified":1676799854027},{"_id":"public/js/plugin.js.map","hash":"1730c0cc660f863120aca0a439d7264e2e245fc5","modified":1676799854027},{"_id":"public/2021/09/24/BuildBlog/blog2.png","hash":"fd54a3e4ee0abcf43b90253988a5ec0028051af7","modified":1676799854027},{"_id":"public/2021/09/24/BuildBlog/blog8.png","hash":"0bd5a927b4ed651ebe5323dc0fcffacb3ba87eff","modified":1676799854027},{"_id":"public/2021/09/27/EdgeR/9.png","hash":"bf3db7a5860965690d6c6fe79684450f7a82fb4b","modified":1676799854027},{"_id":"public/2021/10/09/clusterProfiler/5.png","hash":"e65159879e1148d2632c9a3b025ce66e89e4a4b1","modified":1676799854027},{"_id":"public/2021/09/24/BuildBlog/blog11.png","hash":"b0ebc936b19dba02161025baae8d6d39ad2263c5","modified":1676799854027}],"Category":[{"name":"Blog","_id":"cleb7c83600021q962z2h1y5w"},{"name":"Bioinformatics","_id":"cleb7c83a00071q96gyz70tsa"},{"name":"Statistical Learning Methods","_id":"cleb7c83k000r1q967k4b0v1w"},{"name":"Algorithm","_id":"cleb7c83l000w1q961e7r9nta"}],"Data":[],"Page":[],"Post":[{"title":"Mac下Hexo和Github免费搭建个人网站","date":"2021-09-24T13:08:49.000Z","comment":null,"_content":"# 前言:  \n**1. 这篇文章写来试试效果，99%的内容来自于自网上的教程以及官网的文档，包括但不限于以下链接:**  \n***[https://zhuanlan.zhihu.com/p/111614119](https://zhuanlan.zhihu.com/p/111614119)（主要来源，非常厉害的教程，windows可以直接按照此文进行搭建）  \n[https://hexo.io/zh-cn/docs/](https://hexo.io/zh-cn/docs/)（hexo官方文档，中文版）  \n[http://nodejs.cn/](http://nodejs.cn/)(node.js的中文官网)  \n[https://docs.npmjs.com/](https://docs.npmjs.com/)（npm的官方文档）  \n[https://github.com/](https://github.com/)（github官网）***\n\n**2. 整个过程以Mac系统进行说明。**  \n\n# 正文：  \n## GitHub与Git  \n\n### GitHub的账号注册  \n\n**进入官网([https://github.com/](https://github.com/))后，用邮箱注册一个即可。**  \n\n### 创建GitHub仓库  \n\n打开GitHub网页，登陆账号后，网页右上角有个➕的一个图标，点击它后再点击`New repository`。  \n![](blog1.png)   \n\n这样会出来一个全新的页面，你需要在这个页面上的`Repository name`一栏填入*xxxxxx.github.io*。*xxxxxxx*就是你的GitHub账户名，**整个必须完全一致才行**。然后在`Add a README file`一栏进行打勾勾选，再点击`Create repository`进行创建。  \n![blog2](./blog2.png)  \n\n创建完毕后，访问*xxxxxx.github.io*应该会出现类似于下面这种页面：  \n\n![](blog3.jpeg)  \n\n### Git的安装与设置 \n> Git是一个分布式版本控制系统，本质上就是通过这个软件将所要存储的东西上传至GitHub账户中存储起来，当然也可以在一台全新的电脑上将存储在GitHub中的东西下载下来。推荐廖雪峰大佬的Git教程：https://www.liaoxuefeng.com/wiki/896043488029600。  \n\n**安装：**  \nMac中该软件应是自带。如果没有，请按照此链接[https://git-scm.com/download/mac](https://git-scm.com/download/mac)中的内容进行安装。  \n**设置：**  \n1. 需要在终端对Git进行设置，输入命令`git config --global user.name \"Your Name\"`以及`git config --global user.email \"email@example.com\"`  \n第一个命令最后面是GitHub的用户名，第二个命令最后是GitHub注册时的邮箱。  \n_设置完成后此时仍不能使用Git传输数据到GitHub上，因为传输需要加密。_  \n2. 继续在终端中输入命令`ssh-keygen -t rsa -C \"youremail@example.com\"`，邮件地址为注册账户时的邮件地址。输入该命令后，终端中会出现一些可输入选项，不用理会，一路回车即可。  \n3. 上一个命令完成后，此时家目录中会生成名为`.ssh`的文件夹，输出该目录下的i`d_rsa.pub`文件中的内容，它会是类似下面这种东西：  \n![](blog6.png)  \n4. 这是所需要的密匙，打开GitHub网站并登录，点击右上角的个人头像，并点击`Settings`。  \n![](blog7.png)  \n1. 在新出现的_Account settings_页面中点击`SSH and GPG keys`，再点击右上角绿色的`new SSH key`。  \n![](blog8.png)  \n1. 在key一栏中填入`id_rsa.pub`文件中的内容，title一栏中的内容可随意自取（一般来说是填办公地点）。内容填完后，点击绿色`Add SSH key`。  \n![](blog9.png)  \n\n---  \n\n## Hexo  \n> Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku，是搭建博客的首选框架。\n> 实际上就是通过Hexo这个软件将你写的笔记自动地转换成前端页面，“漂亮”地把md文件展示出来。  \n\n### 安装  \n在安装Hexo之前，需要先安装`Node.js`软件。点击[https://nodejs.org/en/](https://nodejs.org/en/)，下载LTS版本的pkg文件进行安装。安装完成后此时在终端中可使用npm命令，输入`npm install hexo-cli -g`进行全局安装Hexo。如在这一步时出现了***EACCES***权限错误，可根据Hexo官方文档：\n![](blog4.png)  \n进入[https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally](https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally)，根据页面上的方法进行修复。  \nnpm官方提供了两种修复方式，一是*Reinstall npm with a node version manager*；二是*Manually change npm's default directory*。如采用第二种方式（如未能按此方法修复，可在[https://hexo.io/zh-cn/docs/](https://hexo.io/zh-cn/docs/)评论区中寻找类似情况并解决。）：  \n![](blog5.png)  \n在终端中做完这5个步骤后，再使用`npm install hexo-cli -g`进行安装。  \n安装完成后，可使用`npx hexo <command>`调用Hexo。也可先使用`echo PATH=$PATH:./node_modules/.bin >> ~/.profile`命令将 Hexo 所在的目录下的 node_modules 添加到环境变量之中，这样可直接使用 `hexo <command>`  \n\n> 实际上在Mac下，把`export PATH=~/.npm-global/bin:$PATH`以及`export PATH=\"$PATH:./node_modules/.bin\"`放在`~/.bashrc`更为友好。若放在`~/.profile`中，仍需手动`source ~/.profile`才可生效。  \n  \n### 设置  \n输入`hexo -v`可检查版本，测试是否安装成功。  \n家目录下创建名为blog的目录。在此目录下打开终端，依次输入`hexo init`以及`npm install`进行本地hexo的初始化。  \n![blog10](blog10.png)  \n依次使用`hexo g（生成静态网页）` `hexo s（将网页部署到本地）`,然后访问本地[http://localhost:4000/](http://localhost:4000/)，可查看测试网页。  \n![](blog11.png)  \n\n> hexo s等价于 hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。  \n> hexo g 等价于 hexo generate #生成静态网页 (执行 $ hexo g 后会在站点根目录下生成public>文件夹, hexo会将\"<font /blog/source/\" 下面的.md后缀的文件编译为.html后缀的文件,存放在\"/blog/public/ \" 路径下)  \n> hexo d 等价于 hexo deploy #将本地数据部署到远端服务器(如github)  \n> hexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹.  \n\n停止测试网页，打开blog文件，打开其中的_config.yml文件，修改其中下面两段。  \n![](blog12.png)  \n![](blog13.png)  \n若需要将该blog文件上传至GitHub，还需安装扩展，输入`npm i hexo-deployer-git`进行安装。  \n输入`hexo new post \"article title\"`新建一篇md文章。在该文章中编写一些内容后，输入`hexo g`生成静态网页文件，再`hexo d`将blog文件推送至GitHub上。推送完毕后，如无意外，访问`https://用户名.github.io`，将会看到新的网页。  \n\n## 结语  \n**1.Hexo面向md文件进行转化，所以还需学习如何编写md文件。  \n2.Hexo有很多开发好的网页主题，官网上就有许多推荐的主题，可自行取用。  \n3.搭建好的个人网站域名也可更改，谷歌一下即可解决。**","source":"_posts/BuildBlog.md","raw":"---\ntitle: Mac下Hexo和Github免费搭建个人网站\ndate: 2021-09-24 21:08:49\ncomment: \ncategories: \n- Blog\ntags: \n- Blog\n---\n# 前言:  \n**1. 这篇文章写来试试效果，99%的内容来自于自网上的教程以及官网的文档，包括但不限于以下链接:**  \n***[https://zhuanlan.zhihu.com/p/111614119](https://zhuanlan.zhihu.com/p/111614119)（主要来源，非常厉害的教程，windows可以直接按照此文进行搭建）  \n[https://hexo.io/zh-cn/docs/](https://hexo.io/zh-cn/docs/)（hexo官方文档，中文版）  \n[http://nodejs.cn/](http://nodejs.cn/)(node.js的中文官网)  \n[https://docs.npmjs.com/](https://docs.npmjs.com/)（npm的官方文档）  \n[https://github.com/](https://github.com/)（github官网）***\n\n**2. 整个过程以Mac系统进行说明。**  \n\n# 正文：  \n## GitHub与Git  \n\n### GitHub的账号注册  \n\n**进入官网([https://github.com/](https://github.com/))后，用邮箱注册一个即可。**  \n\n### 创建GitHub仓库  \n\n打开GitHub网页，登陆账号后，网页右上角有个➕的一个图标，点击它后再点击`New repository`。  \n![](blog1.png)   \n\n这样会出来一个全新的页面，你需要在这个页面上的`Repository name`一栏填入*xxxxxx.github.io*。*xxxxxxx*就是你的GitHub账户名，**整个必须完全一致才行**。然后在`Add a README file`一栏进行打勾勾选，再点击`Create repository`进行创建。  \n![blog2](./blog2.png)  \n\n创建完毕后，访问*xxxxxx.github.io*应该会出现类似于下面这种页面：  \n\n![](blog3.jpeg)  \n\n### Git的安装与设置 \n> Git是一个分布式版本控制系统，本质上就是通过这个软件将所要存储的东西上传至GitHub账户中存储起来，当然也可以在一台全新的电脑上将存储在GitHub中的东西下载下来。推荐廖雪峰大佬的Git教程：https://www.liaoxuefeng.com/wiki/896043488029600。  \n\n**安装：**  \nMac中该软件应是自带。如果没有，请按照此链接[https://git-scm.com/download/mac](https://git-scm.com/download/mac)中的内容进行安装。  \n**设置：**  \n1. 需要在终端对Git进行设置，输入命令`git config --global user.name \"Your Name\"`以及`git config --global user.email \"email@example.com\"`  \n第一个命令最后面是GitHub的用户名，第二个命令最后是GitHub注册时的邮箱。  \n_设置完成后此时仍不能使用Git传输数据到GitHub上，因为传输需要加密。_  \n2. 继续在终端中输入命令`ssh-keygen -t rsa -C \"youremail@example.com\"`，邮件地址为注册账户时的邮件地址。输入该命令后，终端中会出现一些可输入选项，不用理会，一路回车即可。  \n3. 上一个命令完成后，此时家目录中会生成名为`.ssh`的文件夹，输出该目录下的i`d_rsa.pub`文件中的内容，它会是类似下面这种东西：  \n![](blog6.png)  \n4. 这是所需要的密匙，打开GitHub网站并登录，点击右上角的个人头像，并点击`Settings`。  \n![](blog7.png)  \n1. 在新出现的_Account settings_页面中点击`SSH and GPG keys`，再点击右上角绿色的`new SSH key`。  \n![](blog8.png)  \n1. 在key一栏中填入`id_rsa.pub`文件中的内容，title一栏中的内容可随意自取（一般来说是填办公地点）。内容填完后，点击绿色`Add SSH key`。  \n![](blog9.png)  \n\n---  \n\n## Hexo  \n> Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku，是搭建博客的首选框架。\n> 实际上就是通过Hexo这个软件将你写的笔记自动地转换成前端页面，“漂亮”地把md文件展示出来。  \n\n### 安装  \n在安装Hexo之前，需要先安装`Node.js`软件。点击[https://nodejs.org/en/](https://nodejs.org/en/)，下载LTS版本的pkg文件进行安装。安装完成后此时在终端中可使用npm命令，输入`npm install hexo-cli -g`进行全局安装Hexo。如在这一步时出现了***EACCES***权限错误，可根据Hexo官方文档：\n![](blog4.png)  \n进入[https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally](https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally)，根据页面上的方法进行修复。  \nnpm官方提供了两种修复方式，一是*Reinstall npm with a node version manager*；二是*Manually change npm's default directory*。如采用第二种方式（如未能按此方法修复，可在[https://hexo.io/zh-cn/docs/](https://hexo.io/zh-cn/docs/)评论区中寻找类似情况并解决。）：  \n![](blog5.png)  \n在终端中做完这5个步骤后，再使用`npm install hexo-cli -g`进行安装。  \n安装完成后，可使用`npx hexo <command>`调用Hexo。也可先使用`echo PATH=$PATH:./node_modules/.bin >> ~/.profile`命令将 Hexo 所在的目录下的 node_modules 添加到环境变量之中，这样可直接使用 `hexo <command>`  \n\n> 实际上在Mac下，把`export PATH=~/.npm-global/bin:$PATH`以及`export PATH=\"$PATH:./node_modules/.bin\"`放在`~/.bashrc`更为友好。若放在`~/.profile`中，仍需手动`source ~/.profile`才可生效。  \n  \n### 设置  \n输入`hexo -v`可检查版本，测试是否安装成功。  \n家目录下创建名为blog的目录。在此目录下打开终端，依次输入`hexo init`以及`npm install`进行本地hexo的初始化。  \n![blog10](blog10.png)  \n依次使用`hexo g（生成静态网页）` `hexo s（将网页部署到本地）`,然后访问本地[http://localhost:4000/](http://localhost:4000/)，可查看测试网页。  \n![](blog11.png)  \n\n> hexo s等价于 hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。  \n> hexo g 等价于 hexo generate #生成静态网页 (执行 $ hexo g 后会在站点根目录下生成public>文件夹, hexo会将\"<font /blog/source/\" 下面的.md后缀的文件编译为.html后缀的文件,存放在\"/blog/public/ \" 路径下)  \n> hexo d 等价于 hexo deploy #将本地数据部署到远端服务器(如github)  \n> hexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹.  \n\n停止测试网页，打开blog文件，打开其中的_config.yml文件，修改其中下面两段。  \n![](blog12.png)  \n![](blog13.png)  \n若需要将该blog文件上传至GitHub，还需安装扩展，输入`npm i hexo-deployer-git`进行安装。  \n输入`hexo new post \"article title\"`新建一篇md文章。在该文章中编写一些内容后，输入`hexo g`生成静态网页文件，再`hexo d`将blog文件推送至GitHub上。推送完毕后，如无意外，访问`https://用户名.github.io`，将会看到新的网页。  \n\n## 结语  \n**1.Hexo面向md文件进行转化，所以还需学习如何编写md文件。  \n2.Hexo有很多开发好的网页主题，官网上就有许多推荐的主题，可自行取用。  \n3.搭建好的个人网站域名也可更改，谷歌一下即可解决。**","slug":"BuildBlog","published":1,"updated":"2023-02-18T15:17:46.814Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cleb7c83000001q96cj31e303","content":"<h1 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\"></a> 前言:</h1>\n<p><strong>1. 这篇文章写来试试效果，99%的内容来自于自网上的教程以及官网的文档，包括但不限于以下链接:</strong><br>\n<em><strong><a href=\"https://zhuanlan.zhihu.com/p/111614119\">https://zhuanlan.zhihu.com/p/111614119</a>（主要来源，非常厉害的教程，windows可以直接按照此文进行搭建）<br>\n<a href=\"https://hexo.io/zh-cn/docs/\">https://hexo.io/zh-cn/docs/</a>（hexo官方文档，中文版）<br>\n<a href=\"http://nodejs.cn/\">http://nodejs.cn/</a>(node.js的中文官网)<br>\n<a href=\"https://docs.npmjs.com/\">https://docs.npmjs.com/</a>（npm的官方文档）<br>\n<a href=\"https://github.com/\">https://github.com/</a>（github官网）</strong></em></p>\n<p><strong>2. 整个过程以Mac系统进行说明。</strong></p>\n<h1 id=\"正文\"><a class=\"markdownIt-Anchor\" href=\"#正文\"></a> 正文：</h1>\n<h2 id=\"github与git\"><a class=\"markdownIt-Anchor\" href=\"#github与git\"></a> GitHub与Git</h2>\n<h3 id=\"github的账号注册\"><a class=\"markdownIt-Anchor\" href=\"#github的账号注册\"></a> GitHub的账号注册</h3>\n<p><strong>进入官网(<a href=\"https://github.com/\">https://github.com/</a>)后，用邮箱注册一个即可。</strong></p>\n<h3 id=\"创建github仓库\"><a class=\"markdownIt-Anchor\" href=\"#创建github仓库\"></a> 创建GitHub仓库</h3>\n<p>打开GitHub网页，登陆账号后，网页右上角有个➕的一个图标，点击它后再点击<code>New repository</code>。<br>\n<img src=\"/2021/09/24/BuildBlog/blog1.png\" alt></p>\n<p>这样会出来一个全新的页面，你需要在这个页面上的<code>Repository name</code>一栏填入<em><a href=\"http://xxxxxx.github.io\">xxxxxx.github.io</a></em>。<em>xxxxxxx</em>就是你的GitHub账户名，<strong>整个必须完全一致才行</strong>。然后在<code>Add a README file</code>一栏进行打勾勾选，再点击<code>Create repository</code>进行创建。</p>\n<img src=\"/2021/09/24/BuildBlog/blog2.png\" class title=\"blog2\">  \n<p>创建完毕后，访问<em><a href=\"http://xxxxxx.github.io\">xxxxxx.github.io</a></em>应该会出现类似于下面这种页面：</p>\n<p><img src=\"/2021/09/24/BuildBlog/blog3.jpeg\" alt></p>\n<h3 id=\"git的安装与设置\"><a class=\"markdownIt-Anchor\" href=\"#git的安装与设置\"></a> Git的安装与设置</h3>\n<blockquote>\n<p>Git是一个分布式版本控制系统，本质上就是通过这个软件将所要存储的东西上传至GitHub账户中存储起来，当然也可以在一台全新的电脑上将存储在GitHub中的东西下载下来。推荐廖雪峰大佬的Git教程：<a href=\"https://www.liaoxuefeng.com/wiki/896043488029600%E3%80%82\">https://www.liaoxuefeng.com/wiki/896043488029600。</a></p>\n</blockquote>\n<p><strong>安装：</strong><br>\nMac中该软件应是自带。如果没有，请按照此链接<a href=\"https://git-scm.com/download/mac\">https://git-scm.com/download/mac</a>中的内容进行安装。<br>\n<strong>设置：</strong></p>\n<ol>\n<li>需要在终端对Git进行设置，输入命令<code>git config --global user.name &quot;Your Name&quot;</code>以及<code>git config --global user.email &quot;email@example.com&quot;</code><br>\n第一个命令最后面是GitHub的用户名，第二个命令最后是GitHub注册时的邮箱。<br>\n<em>设置完成后此时仍不能使用Git传输数据到GitHub上，因为传输需要加密。</em></li>\n<li>继续在终端中输入命令<code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code>，邮件地址为注册账户时的邮件地址。输入该命令后，终端中会出现一些可输入选项，不用理会，一路回车即可。</li>\n<li>上一个命令完成后，此时家目录中会生成名为<code>.ssh</code>的文件夹，输出该目录下的i<code>d_rsa.pub</code>文件中的内容，它会是类似下面这种东西：<br>\n<img src=\"/2021/09/24/BuildBlog/blog6.png\" alt></li>\n<li>这是所需要的密匙，打开GitHub网站并登录，点击右上角的个人头像，并点击<code>Settings</code>。<br>\n<img src=\"/2021/09/24/BuildBlog/blog7.png\" alt></li>\n<li>在新出现的_Account settings_页面中点击<code>SSH and GPG keys</code>，再点击右上角绿色的<code>new SSH key</code>。<br>\n<img src=\"/2021/09/24/BuildBlog/blog8.png\" alt></li>\n<li>在key一栏中填入<code>id_rsa.pub</code>文件中的内容，title一栏中的内容可随意自取（一般来说是填办公地点）。内容填完后，点击绿色<code>Add SSH key</code>。<br>\n<img src=\"/2021/09/24/BuildBlog/blog9.png\" alt></li>\n</ol>\n<hr>\n<h2 id=\"hexo\"><a class=\"markdownIt-Anchor\" href=\"#hexo\"></a> Hexo</h2>\n<blockquote>\n<p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku，是搭建博客的首选框架。<br>\n实际上就是通过Hexo这个软件将你写的笔记自动地转换成前端页面，“漂亮”地把md文件展示出来。</p>\n</blockquote>\n<h3 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h3>\n<p>在安装Hexo之前，需要先安装<code>Node.js</code>软件。点击<a href=\"https://nodejs.org/en/\">https://nodejs.org/en/</a>，下载LTS版本的pkg文件进行安装。安装完成后此时在终端中可使用npm命令，输入<code>npm install hexo-cli -g</code>进行全局安装Hexo。如在这一步时出现了<em><strong>EACCES</strong></em>权限错误，可根据Hexo官方文档：<br>\n<img src=\"/2021/09/24/BuildBlog/blog4.png\" alt><br>\n进入<a href=\"https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally\">https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally</a>，根据页面上的方法进行修复。<br>\nnpm官方提供了两种修复方式，一是<em>Reinstall npm with a node version manager</em>；二是<em>Manually change npm’s default directory</em>。如采用第二种方式（如未能按此方法修复，可在<a href=\"https://hexo.io/zh-cn/docs/\">https://hexo.io/zh-cn/docs/</a>评论区中寻找类似情况并解决。）：<br>\n<img src=\"/2021/09/24/BuildBlog/blog5.png\" alt><br>\n在终端中做完这5个步骤后，再使用<code>npm install hexo-cli -g</code>进行安装。<br>\n安装完成后，可使用<code>npx hexo &lt;command&gt;</code>调用Hexo。也可先使用<code>echo PATH=$PATH:./node_modules/.bin &gt;&gt; ~/.profile</code>命令将 Hexo 所在的目录下的 node_modules 添加到环境变量之中，这样可直接使用 <code>hexo &lt;command&gt;</code></p>\n<blockquote>\n<p>实际上在Mac下，把<code>export PATH=~/.npm-global/bin:$PATH</code>以及<code>export PATH=&quot;$PATH:./node_modules/.bin&quot;</code>放在<code>~/.bashrc</code>更为友好。若放在<code>~/.profile</code>中，仍需手动<code>source ~/.profile</code>才可生效。</p>\n</blockquote>\n<h3 id=\"设置\"><a class=\"markdownIt-Anchor\" href=\"#设置\"></a> 设置</h3>\n<p>输入<code>hexo -v</code>可检查版本，测试是否安装成功。<br>\n家目录下创建名为blog的目录。在此目录下打开终端，依次输入<code>hexo init</code>以及<code>npm install</code>进行本地hexo的初始化。<br>\n<img src=\"/2021/09/24/BuildBlog/blog10.png\" alt=\"blog10\"><br>\n依次使用<code>hexo g（生成静态网页）</code> <code>hexo s（将网页部署到本地）</code>,然后访问本地<a href=\"http://localhost:4000/\">http://localhost:4000/</a>，可查看测试网页。<br>\n<img src=\"/2021/09/24/BuildBlog/blog11.png\" alt></p>\n<blockquote>\n<p>hexo s等价于 hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。<br>\nhexo g 等价于 hexo generate #生成静态网页 (执行 $ hexo g 后会在站点根目录下生成public&gt;文件夹, hexo会将&quot;&lt;font /blog/source/&quot; 下面的.md后缀的文件编译为.html后缀的文件,存放在&quot;/blog/public/ &quot; 路径下)<br>\nhexo d 等价于 hexo deploy #将本地数据部署到远端服务器(如github)<br>\nhexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹.</p>\n</blockquote>\n<p>停止测试网页，打开blog文件，打开其中的_config.yml文件，修改其中下面两段。<br>\n<img src=\"/2021/09/24/BuildBlog/blog12.png\" alt><br>\n<img src=\"/2021/09/24/BuildBlog/blog13.png\" alt><br>\n若需要将该blog文件上传至GitHub，还需安装扩展，输入<code>npm i hexo-deployer-git</code>进行安装。<br>\n输入<code>hexo new post &quot;article title&quot;</code>新建一篇md文章。在该文章中编写一些内容后，输入<code>hexo g</code>生成静态网页文件，再<code>hexo d</code>将blog文件推送至GitHub上。推送完毕后，如无意外，访问<code>https://用户名.github.io</code>，将会看到新的网页。</p>\n<h2 id=\"结语\"><a class=\"markdownIt-Anchor\" href=\"#结语\"></a> 结语</h2>\n<p><strong>1.Hexo面向md文件进行转化，所以还需学习如何编写md文件。<br>\n2.Hexo有很多开发好的网页主题，官网上就有许多推荐的主题，可自行取用。<br>\n3.搭建好的个人网站域名也可更改，谷歌一下即可解决。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\"></a> 前言:</h1>\n<p><strong>1. 这篇文章写来试试效果，99%的内容来自于自网上的教程以及官网的文档，包括但不限于以下链接:</strong><br>\n<em><strong><a href=\"https://zhuanlan.zhihu.com/p/111614119\">https://zhuanlan.zhihu.com/p/111614119</a>（主要来源，非常厉害的教程，windows可以直接按照此文进行搭建）<br>\n<a href=\"https://hexo.io/zh-cn/docs/\">https://hexo.io/zh-cn/docs/</a>（hexo官方文档，中文版）<br>\n<a href=\"http://nodejs.cn/\">http://nodejs.cn/</a>(node.js的中文官网)<br>\n<a href=\"https://docs.npmjs.com/\">https://docs.npmjs.com/</a>（npm的官方文档）<br>\n<a href=\"https://github.com/\">https://github.com/</a>（github官网）</strong></em></p>\n<p><strong>2. 整个过程以Mac系统进行说明。</strong></p>\n<h1 id=\"正文\"><a class=\"markdownIt-Anchor\" href=\"#正文\"></a> 正文：</h1>\n<h2 id=\"github与git\"><a class=\"markdownIt-Anchor\" href=\"#github与git\"></a> GitHub与Git</h2>\n<h3 id=\"github的账号注册\"><a class=\"markdownIt-Anchor\" href=\"#github的账号注册\"></a> GitHub的账号注册</h3>\n<p><strong>进入官网(<a href=\"https://github.com/\">https://github.com/</a>)后，用邮箱注册一个即可。</strong></p>\n<h3 id=\"创建github仓库\"><a class=\"markdownIt-Anchor\" href=\"#创建github仓库\"></a> 创建GitHub仓库</h3>\n<p>打开GitHub网页，登陆账号后，网页右上角有个➕的一个图标，点击它后再点击<code>New repository</code>。<br>\n<img src=\"/2021/09/24/BuildBlog/blog1.png\" alt></p>\n<p>这样会出来一个全新的页面，你需要在这个页面上的<code>Repository name</code>一栏填入<em><a href=\"http://xxxxxx.github.io\">xxxxxx.github.io</a></em>。<em>xxxxxxx</em>就是你的GitHub账户名，<strong>整个必须完全一致才行</strong>。然后在<code>Add a README file</code>一栏进行打勾勾选，再点击<code>Create repository</code>进行创建。</p>\n<img src=\"/2021/09/24/BuildBlog/blog2.png\" class title=\"blog2\">  \n<p>创建完毕后，访问<em><a href=\"http://xxxxxx.github.io\">xxxxxx.github.io</a></em>应该会出现类似于下面这种页面：</p>\n<p><img src=\"/2021/09/24/BuildBlog/blog3.jpeg\" alt></p>\n<h3 id=\"git的安装与设置\"><a class=\"markdownIt-Anchor\" href=\"#git的安装与设置\"></a> Git的安装与设置</h3>\n<blockquote>\n<p>Git是一个分布式版本控制系统，本质上就是通过这个软件将所要存储的东西上传至GitHub账户中存储起来，当然也可以在一台全新的电脑上将存储在GitHub中的东西下载下来。推荐廖雪峰大佬的Git教程：<a href=\"https://www.liaoxuefeng.com/wiki/896043488029600%E3%80%82\">https://www.liaoxuefeng.com/wiki/896043488029600。</a></p>\n</blockquote>\n<p><strong>安装：</strong><br>\nMac中该软件应是自带。如果没有，请按照此链接<a href=\"https://git-scm.com/download/mac\">https://git-scm.com/download/mac</a>中的内容进行安装。<br>\n<strong>设置：</strong></p>\n<ol>\n<li>需要在终端对Git进行设置，输入命令<code>git config --global user.name &quot;Your Name&quot;</code>以及<code>git config --global user.email &quot;email@example.com&quot;</code><br>\n第一个命令最后面是GitHub的用户名，第二个命令最后是GitHub注册时的邮箱。<br>\n<em>设置完成后此时仍不能使用Git传输数据到GitHub上，因为传输需要加密。</em></li>\n<li>继续在终端中输入命令<code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code>，邮件地址为注册账户时的邮件地址。输入该命令后，终端中会出现一些可输入选项，不用理会，一路回车即可。</li>\n<li>上一个命令完成后，此时家目录中会生成名为<code>.ssh</code>的文件夹，输出该目录下的i<code>d_rsa.pub</code>文件中的内容，它会是类似下面这种东西：<br>\n<img src=\"/2021/09/24/BuildBlog/blog6.png\" alt></li>\n<li>这是所需要的密匙，打开GitHub网站并登录，点击右上角的个人头像，并点击<code>Settings</code>。<br>\n<img src=\"/2021/09/24/BuildBlog/blog7.png\" alt></li>\n<li>在新出现的_Account settings_页面中点击<code>SSH and GPG keys</code>，再点击右上角绿色的<code>new SSH key</code>。<br>\n<img src=\"/2021/09/24/BuildBlog/blog8.png\" alt></li>\n<li>在key一栏中填入<code>id_rsa.pub</code>文件中的内容，title一栏中的内容可随意自取（一般来说是填办公地点）。内容填完后，点击绿色<code>Add SSH key</code>。<br>\n<img src=\"/2021/09/24/BuildBlog/blog9.png\" alt></li>\n</ol>\n<hr>\n<h2 id=\"hexo\"><a class=\"markdownIt-Anchor\" href=\"#hexo\"></a> Hexo</h2>\n<blockquote>\n<p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku，是搭建博客的首选框架。<br>\n实际上就是通过Hexo这个软件将你写的笔记自动地转换成前端页面，“漂亮”地把md文件展示出来。</p>\n</blockquote>\n<h3 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h3>\n<p>在安装Hexo之前，需要先安装<code>Node.js</code>软件。点击<a href=\"https://nodejs.org/en/\">https://nodejs.org/en/</a>，下载LTS版本的pkg文件进行安装。安装完成后此时在终端中可使用npm命令，输入<code>npm install hexo-cli -g</code>进行全局安装Hexo。如在这一步时出现了<em><strong>EACCES</strong></em>权限错误，可根据Hexo官方文档：<br>\n<img src=\"/2021/09/24/BuildBlog/blog4.png\" alt><br>\n进入<a href=\"https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally\">https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally</a>，根据页面上的方法进行修复。<br>\nnpm官方提供了两种修复方式，一是<em>Reinstall npm with a node version manager</em>；二是<em>Manually change npm’s default directory</em>。如采用第二种方式（如未能按此方法修复，可在<a href=\"https://hexo.io/zh-cn/docs/\">https://hexo.io/zh-cn/docs/</a>评论区中寻找类似情况并解决。）：<br>\n<img src=\"/2021/09/24/BuildBlog/blog5.png\" alt><br>\n在终端中做完这5个步骤后，再使用<code>npm install hexo-cli -g</code>进行安装。<br>\n安装完成后，可使用<code>npx hexo &lt;command&gt;</code>调用Hexo。也可先使用<code>echo PATH=$PATH:./node_modules/.bin &gt;&gt; ~/.profile</code>命令将 Hexo 所在的目录下的 node_modules 添加到环境变量之中，这样可直接使用 <code>hexo &lt;command&gt;</code></p>\n<blockquote>\n<p>实际上在Mac下，把<code>export PATH=~/.npm-global/bin:$PATH</code>以及<code>export PATH=&quot;$PATH:./node_modules/.bin&quot;</code>放在<code>~/.bashrc</code>更为友好。若放在<code>~/.profile</code>中，仍需手动<code>source ~/.profile</code>才可生效。</p>\n</blockquote>\n<h3 id=\"设置\"><a class=\"markdownIt-Anchor\" href=\"#设置\"></a> 设置</h3>\n<p>输入<code>hexo -v</code>可检查版本，测试是否安装成功。<br>\n家目录下创建名为blog的目录。在此目录下打开终端，依次输入<code>hexo init</code>以及<code>npm install</code>进行本地hexo的初始化。<br>\n<img src=\"/2021/09/24/BuildBlog/blog10.png\" alt=\"blog10\"><br>\n依次使用<code>hexo g（生成静态网页）</code> <code>hexo s（将网页部署到本地）</code>,然后访问本地<a href=\"http://localhost:4000/\">http://localhost:4000/</a>，可查看测试网页。<br>\n<img src=\"/2021/09/24/BuildBlog/blog11.png\" alt></p>\n<blockquote>\n<p>hexo s等价于 hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。<br>\nhexo g 等价于 hexo generate #生成静态网页 (执行 $ hexo g 后会在站点根目录下生成public&gt;文件夹, hexo会将&quot;&lt;font /blog/source/&quot; 下面的.md后缀的文件编译为.html后缀的文件,存放在&quot;/blog/public/ &quot; 路径下)<br>\nhexo d 等价于 hexo deploy #将本地数据部署到远端服务器(如github)<br>\nhexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹.</p>\n</blockquote>\n<p>停止测试网页，打开blog文件，打开其中的_config.yml文件，修改其中下面两段。<br>\n<img src=\"/2021/09/24/BuildBlog/blog12.png\" alt><br>\n<img src=\"/2021/09/24/BuildBlog/blog13.png\" alt><br>\n若需要将该blog文件上传至GitHub，还需安装扩展，输入<code>npm i hexo-deployer-git</code>进行安装。<br>\n输入<code>hexo new post &quot;article title&quot;</code>新建一篇md文章。在该文章中编写一些内容后，输入<code>hexo g</code>生成静态网页文件，再<code>hexo d</code>将blog文件推送至GitHub上。推送完毕后，如无意外，访问<code>https://用户名.github.io</code>，将会看到新的网页。</p>\n<h2 id=\"结语\"><a class=\"markdownIt-Anchor\" href=\"#结语\"></a> 结语</h2>\n<p><strong>1.Hexo面向md文件进行转化，所以还需学习如何编写md文件。<br>\n2.Hexo有很多开发好的网页主题，官网上就有许多推荐的主题，可自行取用。<br>\n3.搭建好的个人网站域名也可更改，谷歌一下即可解决。</strong></p>\n"},{"title":"EdgeR查找差异表达基因(二)","date":"2021-10-21T16:00:00.000Z","_content":"# EdgeR查找差异表达基因(二)  \n## 前言  \n第一篇有关于EdgeR处理差异基因的过程中有瑕疵的，这篇文章一是要提出上次过程中没写出的问题，二是要写出有关EdgeR原理方面的东西。  \n## 数据来源  \n癌症细胞：`Encode`上`HepG2`癌症细胞系`total RNA-Seq`的基因定量文件。  \n正常细胞：`Encode`上正常肝组织的`total RNA-Seq`的基因定量文件。  \n\n## 流程中的问题  \n### 基因定量信息  \n上次使用了`Encode`的基因定量文件中`gene_id`和`expected_count`两列组成EdgeR的输入数据文件。这样直接使用是粗糙的。  \n`下载的ENSG数据中常常有小数点，小数点后面的表示的版本类型，在进行匹配时需要删除小数点后面的，一般情况下ENSG一共是15位，所有保留前15位字符就可以了.`  \n**读入数据:**  \n\n> rep1=read.table(\"./ENCFF944RFV.tsv\",header=T)  \n> rep2=read.table(\"./ENCFF529HSE.tsv\",header=T)  \n> rep3=read.table(\"./ENCFF396FZT.tsv\",header=T)  \n> rep4=read.table(\"./ENCFF103FSL.tsv\",header=T)  \n> norm1=read.table(\"~/Project/Normal_tissue/Liver/RNA/ENCFF780YUS.tsv\",header = T)  \n> norm2=read.table(\"~/Project/Normal_tissue/Liver/RNA/ENCFF846SOK.tsv\",header = T)  \n\n**处理gene_id:**  \n以rep1为例:  \n\n> rep1 = rep1[grep('ENSG',test\\$gene_id,invert = F),]    \n> rep1\\$gene_id = substr(rep1\\$gene_id,1,15)  \n> rep1 = aggregate(expected_count ~ gene_id , data = rep1,sum)  \n\n将其他的rep和norm作同样的处理  \n\n**得到矩阵:**  \n\n> count=data.frame(rep1\\$gene_id,rep1\\$expected_count,rep2\\$expected_count,rep3\\$expected_count,rep4\\$expected_count,norm1\\$expected_count,norm2\\$expected_count)  \n> colnames(count)=c('gene_id','rep1','rep2','rep3','rep4','norm1','norm2')  \n> rownames(count)=count$gene_id  \n> count = count[,-c(1)]  \n\n原始矩阵count:  \n\n![](1.png)  \n\n**分组:**  \n\n`分组`步骤同后面的流程息息相关。  \n它会影响`过滤低表达基因`和`检验差异基因`。  \n1.在`过滤表达基因`部分:  \n`The filtering should be based on the grouping factors or treatment factors that will be involved in the differential expression teststested for, rather than on blocking variables that are not of scientific interest in themselves.`  \n2.在`检验差异基因`部分:  \n(1) 单因子分组实验:`The classic edgeR pipeline`--->`edgeR uses the quantile-adjusted conditional maximum likelihood (qCML) method for experiments with single factor.`  \n(2) 多因子复杂分组:`More complex experiments (glm functionality)`--->`Generalized linear models (GLMs) are an extension of classical linear models to nonnormally distributed response data`  ","source":"_posts/EdgeR(2).md","raw":"---\ntitle: EdgeR查找差异表达基因(二)\ndate: 2021-10-22\ncategories: \n- Bioinformatics\ntags: \n- RNA-Seq\n- DE-Analysis\n---\n# EdgeR查找差异表达基因(二)  \n## 前言  \n第一篇有关于EdgeR处理差异基因的过程中有瑕疵的，这篇文章一是要提出上次过程中没写出的问题，二是要写出有关EdgeR原理方面的东西。  \n## 数据来源  \n癌症细胞：`Encode`上`HepG2`癌症细胞系`total RNA-Seq`的基因定量文件。  \n正常细胞：`Encode`上正常肝组织的`total RNA-Seq`的基因定量文件。  \n\n## 流程中的问题  \n### 基因定量信息  \n上次使用了`Encode`的基因定量文件中`gene_id`和`expected_count`两列组成EdgeR的输入数据文件。这样直接使用是粗糙的。  \n`下载的ENSG数据中常常有小数点，小数点后面的表示的版本类型，在进行匹配时需要删除小数点后面的，一般情况下ENSG一共是15位，所有保留前15位字符就可以了.`  \n**读入数据:**  \n\n> rep1=read.table(\"./ENCFF944RFV.tsv\",header=T)  \n> rep2=read.table(\"./ENCFF529HSE.tsv\",header=T)  \n> rep3=read.table(\"./ENCFF396FZT.tsv\",header=T)  \n> rep4=read.table(\"./ENCFF103FSL.tsv\",header=T)  \n> norm1=read.table(\"~/Project/Normal_tissue/Liver/RNA/ENCFF780YUS.tsv\",header = T)  \n> norm2=read.table(\"~/Project/Normal_tissue/Liver/RNA/ENCFF846SOK.tsv\",header = T)  \n\n**处理gene_id:**  \n以rep1为例:  \n\n> rep1 = rep1[grep('ENSG',test\\$gene_id,invert = F),]    \n> rep1\\$gene_id = substr(rep1\\$gene_id,1,15)  \n> rep1 = aggregate(expected_count ~ gene_id , data = rep1,sum)  \n\n将其他的rep和norm作同样的处理  \n\n**得到矩阵:**  \n\n> count=data.frame(rep1\\$gene_id,rep1\\$expected_count,rep2\\$expected_count,rep3\\$expected_count,rep4\\$expected_count,norm1\\$expected_count,norm2\\$expected_count)  \n> colnames(count)=c('gene_id','rep1','rep2','rep3','rep4','norm1','norm2')  \n> rownames(count)=count$gene_id  \n> count = count[,-c(1)]  \n\n原始矩阵count:  \n\n![](1.png)  \n\n**分组:**  \n\n`分组`步骤同后面的流程息息相关。  \n它会影响`过滤低表达基因`和`检验差异基因`。  \n1.在`过滤表达基因`部分:  \n`The filtering should be based on the grouping factors or treatment factors that will be involved in the differential expression teststested for, rather than on blocking variables that are not of scientific interest in themselves.`  \n2.在`检验差异基因`部分:  \n(1) 单因子分组实验:`The classic edgeR pipeline`--->`edgeR uses the quantile-adjusted conditional maximum likelihood (qCML) method for experiments with single factor.`  \n(2) 多因子复杂分组:`More complex experiments (glm functionality)`--->`Generalized linear models (GLMs) are an extension of classical linear models to nonnormally distributed response data`  ","slug":"EdgeR(2)","published":1,"updated":"2023-02-18T15:19:49.638Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cleb7c83400011q96eqdue0mp","content":"<h1 id=\"edger查找差异表达基因二\"><a class=\"markdownIt-Anchor\" href=\"#edger查找差异表达基因二\"></a> EdgeR查找差异表达基因(二)</h1>\n<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\"></a> 前言</h2>\n<p>第一篇有关于EdgeR处理差异基因的过程中有瑕疵的，这篇文章一是要提出上次过程中没写出的问题，二是要写出有关EdgeR原理方面的东西。</p>\n<h2 id=\"数据来源\"><a class=\"markdownIt-Anchor\" href=\"#数据来源\"></a> 数据来源</h2>\n<p>癌症细胞：<code>Encode</code>上<code>HepG2</code>癌症细胞系<code>total RNA-Seq</code>的基因定量文件。<br>\n正常细胞：<code>Encode</code>上正常肝组织的<code>total RNA-Seq</code>的基因定量文件。</p>\n<h2 id=\"流程中的问题\"><a class=\"markdownIt-Anchor\" href=\"#流程中的问题\"></a> 流程中的问题</h2>\n<h3 id=\"基因定量信息\"><a class=\"markdownIt-Anchor\" href=\"#基因定量信息\"></a> 基因定量信息</h3>\n<p>上次使用了<code>Encode</code>的基因定量文件中<code>gene_id</code>和<code>expected_count</code>两列组成EdgeR的输入数据文件。这样直接使用是粗糙的。<br>\n<code>下载的ENSG数据中常常有小数点，小数点后面的表示的版本类型，在进行匹配时需要删除小数点后面的，一般情况下ENSG一共是15位，所有保留前15位字符就可以了.</code><br>\n<strong>读入数据:</strong></p>\n<blockquote>\n<p>rep1=read.table(“./ENCFF944RFV.tsv”,header=T)<br>\nrep2=read.table(“./ENCFF529HSE.tsv”,header=T)<br>\nrep3=read.table(“./ENCFF396FZT.tsv”,header=T)<br>\nrep4=read.table(“./ENCFF103FSL.tsv”,header=T)<br>\nnorm1=read.table(“~/Project/Normal_tissue/Liver/RNA/ENCFF780YUS.tsv”,header = T)<br>\nnorm2=read.table(“~/Project/Normal_tissue/Liver/RNA/ENCFF846SOK.tsv”,header = T)</p>\n</blockquote>\n<p><strong>处理gene_id:</strong><br>\n以rep1为例:</p>\n<blockquote>\n<p>rep1 = rep1[grep(‘ENSG’,test$gene_id,invert = F),]<br>\nrep1$gene_id = substr(rep1$gene_id,1,15)<br>\nrep1 = aggregate(expected_count ~ gene_id , data = rep1,sum)</p>\n</blockquote>\n<p>将其他的rep和norm作同样的处理</p>\n<p><strong>得到矩阵:</strong></p>\n<blockquote>\n<p>count=data.frame(rep1$gene_id,rep1$expected_count,rep2$expected_count,rep3$expected_count,rep4$expected_count,norm1$expected_count,norm2$expected_count)<br>\ncolnames(count)=c(‘gene_id’,‘rep1’,‘rep2’,‘rep3’,‘rep4’,‘norm1’,‘norm2’)<br>\nrownames(count)=count$gene_id<br>\ncount = count[,-c(1)]</p>\n</blockquote>\n<p>原始矩阵count:</p>\n<p><img src=\"/2021/10/22/EdgeR(2)/1.png\" alt></p>\n<p><strong>分组:</strong></p>\n<p><code>分组</code>步骤同后面的流程息息相关。<br>\n它会影响<code>过滤低表达基因</code>和<code>检验差异基因</code>。<br>\n1.在<code>过滤表达基因</code>部分:<br>\n<code>The filtering should be based on the grouping factors or treatment factors that will be involved in the differential expression teststested for, rather than on blocking variables that are not of scientific interest in themselves.</code><br>\n2.在<code>检验差异基因</code>部分:<br>\n(1) 单因子分组实验:<code>The classic edgeR pipeline</code>—&gt;<code>edgeR uses the quantile-adjusted conditional maximum likelihood (qCML) method for experiments with single factor.</code><br>\n(2) 多因子复杂分组:<code>More complex experiments (glm functionality)</code>—&gt;<code>Generalized linear models (GLMs) are an extension of classical linear models to nonnormally distributed response data</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"edger查找差异表达基因二\"><a class=\"markdownIt-Anchor\" href=\"#edger查找差异表达基因二\"></a> EdgeR查找差异表达基因(二)</h1>\n<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\"></a> 前言</h2>\n<p>第一篇有关于EdgeR处理差异基因的过程中有瑕疵的，这篇文章一是要提出上次过程中没写出的问题，二是要写出有关EdgeR原理方面的东西。</p>\n<h2 id=\"数据来源\"><a class=\"markdownIt-Anchor\" href=\"#数据来源\"></a> 数据来源</h2>\n<p>癌症细胞：<code>Encode</code>上<code>HepG2</code>癌症细胞系<code>total RNA-Seq</code>的基因定量文件。<br>\n正常细胞：<code>Encode</code>上正常肝组织的<code>total RNA-Seq</code>的基因定量文件。</p>\n<h2 id=\"流程中的问题\"><a class=\"markdownIt-Anchor\" href=\"#流程中的问题\"></a> 流程中的问题</h2>\n<h3 id=\"基因定量信息\"><a class=\"markdownIt-Anchor\" href=\"#基因定量信息\"></a> 基因定量信息</h3>\n<p>上次使用了<code>Encode</code>的基因定量文件中<code>gene_id</code>和<code>expected_count</code>两列组成EdgeR的输入数据文件。这样直接使用是粗糙的。<br>\n<code>下载的ENSG数据中常常有小数点，小数点后面的表示的版本类型，在进行匹配时需要删除小数点后面的，一般情况下ENSG一共是15位，所有保留前15位字符就可以了.</code><br>\n<strong>读入数据:</strong></p>\n<blockquote>\n<p>rep1=read.table(“./ENCFF944RFV.tsv”,header=T)<br>\nrep2=read.table(“./ENCFF529HSE.tsv”,header=T)<br>\nrep3=read.table(“./ENCFF396FZT.tsv”,header=T)<br>\nrep4=read.table(“./ENCFF103FSL.tsv”,header=T)<br>\nnorm1=read.table(“~/Project/Normal_tissue/Liver/RNA/ENCFF780YUS.tsv”,header = T)<br>\nnorm2=read.table(“~/Project/Normal_tissue/Liver/RNA/ENCFF846SOK.tsv”,header = T)</p>\n</blockquote>\n<p><strong>处理gene_id:</strong><br>\n以rep1为例:</p>\n<blockquote>\n<p>rep1 = rep1[grep(‘ENSG’,test$gene_id,invert = F),]<br>\nrep1$gene_id = substr(rep1$gene_id,1,15)<br>\nrep1 = aggregate(expected_count ~ gene_id , data = rep1,sum)</p>\n</blockquote>\n<p>将其他的rep和norm作同样的处理</p>\n<p><strong>得到矩阵:</strong></p>\n<blockquote>\n<p>count=data.frame(rep1$gene_id,rep1$expected_count,rep2$expected_count,rep3$expected_count,rep4$expected_count,norm1$expected_count,norm2$expected_count)<br>\ncolnames(count)=c(‘gene_id’,‘rep1’,‘rep2’,‘rep3’,‘rep4’,‘norm1’,‘norm2’)<br>\nrownames(count)=count$gene_id<br>\ncount = count[,-c(1)]</p>\n</blockquote>\n<p>原始矩阵count:</p>\n<p><img src=\"/2021/10/22/EdgeR(2)/1.png\" alt></p>\n<p><strong>分组:</strong></p>\n<p><code>分组</code>步骤同后面的流程息息相关。<br>\n它会影响<code>过滤低表达基因</code>和<code>检验差异基因</code>。<br>\n1.在<code>过滤表达基因</code>部分:<br>\n<code>The filtering should be based on the grouping factors or treatment factors that will be involved in the differential expression teststested for, rather than on blocking variables that are not of scientific interest in themselves.</code><br>\n2.在<code>检验差异基因</code>部分:<br>\n(1) 单因子分组实验:<code>The classic edgeR pipeline</code>—&gt;<code>edgeR uses the quantile-adjusted conditional maximum likelihood (qCML) method for experiments with single factor.</code><br>\n(2) 多因子复杂分组:<code>More complex experiments (glm functionality)</code>—&gt;<code>Generalized linear models (GLMs) are an extension of classical linear models to nonnormally distributed response data</code></p>\n"},{"title":"EdgeR查找差异表达基因","date":"2021-09-26T16:00:00.000Z","_content":"# EdgeR查找差异表达基因  \n内容主要来源：  \n[https://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf](https://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf)（官方使用文档)  \n\n## 数据来源  \n\n癌症细胞：`Encode`上`NCI-H460`癌症细胞系`total RNA-Seq`数据，因为`Encode`已经给出了基因定量的数据文件，故无需再重复跑一次产出定量文件的流程。  \n正常细胞：仍然来自于`Encode`,选用的正常肺组织的`total RNA-Seq`的基因定量文件。  \n![](1.png)   \n\n## 过程  \n### 基因定量信息  \n***Files need to contain two columns, one for the counts and one for a gene identifier.***  \n\n所需的定量文件共两列，一列基因，一列基因的数量。从Encode上下载下来的文件内容是这样的:  \n\n ![](2.png)  \n\n***Note that edgeR is designed to work with actual read counts. We not recommend that predicted transcript abundances are input the edgeR in place of actual counts.***  \n根据文档，要求我们使用初始的基因读数，这里使用了`gene_id`和`expected_count`两列组成EdgeR的输入数据文件。  \n<br />\n**读入初始数据:**  \n\n> rep1=read.table(\"./NCI-H460.totalRNA.geneQA.rep1.tsv\",header =  TRUE)  \n> rep2=read.table(\"./NCI-H460.totalRNA.geneQA.rep2.tsv\",header =  TRUE)  \n> norm1=read.table(\"./lung.toalRNA.geneQA.rep1.tsv\",header =  TRUE)  \n> norm2=read.table(\"./lung.toalRNA.geneQA.rep2.tsv\",header =  TRUE)  \n\n<br />\n\n**提取所需两列:**  \n\n>rep1=rep1[,1:5]  \n>rep1=rep1[,-c(2:4)]  \n\n其他rep2、norm1、norm2按照同样操作即可。  \n\n\n**汇成总表：**  \n\n> count=merge(norm1,norm2,by=\"gene\\_id\")  \n> colnames(count)=c(\"gene\\_id\",\"nomr1\",\"norm2\")  \n> count=merge(count,rep1,by='gene\\_id')  \n> count=merge(count,rep2,by='gene\\_id')  \n> colnames(count)=c('gene\\_Id','norm1','norm2','rep1','rep2')  \n> row.names(count)=count$gene\\_Id  \n> count=count[,-c(1)]  \n\n![](3.png)  \n\n**转换成DGEList类型：**  \n分组并转换：\n> group=c(\"norm\",\"norm\",\"cancer\",\"cancer\")  \n> y=DGEList(counts=count,group = group)  \n\n![](4.png)  \n如图上所示，rep1与rep2的lib.size的差异有点大。重新检查了下，确认并没有下载错误的文件，那么作为试水，继续进行下去吧。  \n\n**过滤低表达基因：**    \n从生物学的角度来看，一个基因必须在某种最低水平上表达，才有可能被翻译成蛋白质或具有生物学上的重要性。此外，这些计数的显著离散性也干扰了后面流程中使用的一些统计近似过程。  \n\n![](5.png)  \n\n直接用`filterByExpr`进行过滤:  \n\n> keep=filterByExpr(y,group = group)  \n> y=y[keep,,keep.lib.sizes=FALSE]  \n\n*keep应该是逻辑类型的向量，它其中代表的意义是哪些基因应该留下来，哪些基因该被筛选出去，故有第二步，需要根据keep对y做处理，才是真正意义上的筛选。*  \n\n### Normalization（标准化)  \n此时y中的样本之间仍然无法进行比较，样本的表达量是在相对不同的条件下测得的，而我们又恰恰需要观察样本之间本身的差异，需要将它们标准化。  \nEdgeR标准化没有将基因长度和GC含量作为主要因素，它把Sequencing depth和Effective library sizes作为标准化主要的方向。  \n\n直接进行标准化：`y = calcNormFactors(y)`  \n![](6.png)  \n\n`norm.factors`发生了变化。  \n\n*We call the product of the original library size and the scaling factor the effective library size. The effective library size replaces the original library size in all downsteam analyses*  \n\n在下面的分析中都是以这个`effective library size`为准。  \n\n`effective library size = original library size * norm.factors`  \n\n### 查找差异基因  \n\n**经典的edgeR分析：**  \n\n*edgeR uses the quantile-adjusted conditional maximum likelihood (qCML) method for experiments with single factor*  \n \n该方法适用于单因子。  \n直接上命令:  \n`y = estimateDisp(y)`  \n`et = exactTest(y)`  \n`topTags(et)`  \n![](7.png)  \n显示的是norm组和cancer组之间的靠前显著基因。  \n如果想要更进一步进行筛选的话，可以按照`et$table`中的四个列进行筛选。  \n如：logFC > 2 并且 p值 < 0.05  \n`ed = et$table[which(et$table$logFC > 2 & et$table$PValue < 0.05),]`  \n\n![](8.png)  \n\n**转换基因名**  \n来源：[https://github.com/twbattaglia/RNAseq-workflow](https://github.com/twbattaglia/RNAseq-workflow)  \n\n`library(org.Hs.eg.db)`  \n`sy = mapIds(x = org.Hs.eg.db,keys = substr(row.names(ed),1,15),keytype = 'ENSEMBL',column = 'SYMBOL',multiVals = 'first')`  \n`ed$symbol = sy`  \n\n*注意事项：转换的时候，ENSGXXXXXXXXXX.XX，需要去除小数点以及小数点后两位的数字。*  \n![](9.png)  \n\n## 后续  \n1.下游分析（GO、KEGG）以及可视化（热图，火山图）。  \n2.原理（长期）。","source":"_posts/EdgeR.md","raw":"---\ntitle: EdgeR查找差异表达基因\ndate: 2021-09-27\ncategories: \n- Bioinformatics\ntags: \n- RNA-Seq\n- DE-Analysis\n---\n# EdgeR查找差异表达基因  \n内容主要来源：  \n[https://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf](https://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf)（官方使用文档)  \n\n## 数据来源  \n\n癌症细胞：`Encode`上`NCI-H460`癌症细胞系`total RNA-Seq`数据，因为`Encode`已经给出了基因定量的数据文件，故无需再重复跑一次产出定量文件的流程。  \n正常细胞：仍然来自于`Encode`,选用的正常肺组织的`total RNA-Seq`的基因定量文件。  \n![](1.png)   \n\n## 过程  \n### 基因定量信息  \n***Files need to contain two columns, one for the counts and one for a gene identifier.***  \n\n所需的定量文件共两列，一列基因，一列基因的数量。从Encode上下载下来的文件内容是这样的:  \n\n ![](2.png)  \n\n***Note that edgeR is designed to work with actual read counts. We not recommend that predicted transcript abundances are input the edgeR in place of actual counts.***  \n根据文档，要求我们使用初始的基因读数，这里使用了`gene_id`和`expected_count`两列组成EdgeR的输入数据文件。  \n<br />\n**读入初始数据:**  \n\n> rep1=read.table(\"./NCI-H460.totalRNA.geneQA.rep1.tsv\",header =  TRUE)  \n> rep2=read.table(\"./NCI-H460.totalRNA.geneQA.rep2.tsv\",header =  TRUE)  \n> norm1=read.table(\"./lung.toalRNA.geneQA.rep1.tsv\",header =  TRUE)  \n> norm2=read.table(\"./lung.toalRNA.geneQA.rep2.tsv\",header =  TRUE)  \n\n<br />\n\n**提取所需两列:**  \n\n>rep1=rep1[,1:5]  \n>rep1=rep1[,-c(2:4)]  \n\n其他rep2、norm1、norm2按照同样操作即可。  \n\n\n**汇成总表：**  \n\n> count=merge(norm1,norm2,by=\"gene\\_id\")  \n> colnames(count)=c(\"gene\\_id\",\"nomr1\",\"norm2\")  \n> count=merge(count,rep1,by='gene\\_id')  \n> count=merge(count,rep2,by='gene\\_id')  \n> colnames(count)=c('gene\\_Id','norm1','norm2','rep1','rep2')  \n> row.names(count)=count$gene\\_Id  \n> count=count[,-c(1)]  \n\n![](3.png)  \n\n**转换成DGEList类型：**  \n分组并转换：\n> group=c(\"norm\",\"norm\",\"cancer\",\"cancer\")  \n> y=DGEList(counts=count,group = group)  \n\n![](4.png)  \n如图上所示，rep1与rep2的lib.size的差异有点大。重新检查了下，确认并没有下载错误的文件，那么作为试水，继续进行下去吧。  \n\n**过滤低表达基因：**    \n从生物学的角度来看，一个基因必须在某种最低水平上表达，才有可能被翻译成蛋白质或具有生物学上的重要性。此外，这些计数的显著离散性也干扰了后面流程中使用的一些统计近似过程。  \n\n![](5.png)  \n\n直接用`filterByExpr`进行过滤:  \n\n> keep=filterByExpr(y,group = group)  \n> y=y[keep,,keep.lib.sizes=FALSE]  \n\n*keep应该是逻辑类型的向量，它其中代表的意义是哪些基因应该留下来，哪些基因该被筛选出去，故有第二步，需要根据keep对y做处理，才是真正意义上的筛选。*  \n\n### Normalization（标准化)  \n此时y中的样本之间仍然无法进行比较，样本的表达量是在相对不同的条件下测得的，而我们又恰恰需要观察样本之间本身的差异，需要将它们标准化。  \nEdgeR标准化没有将基因长度和GC含量作为主要因素，它把Sequencing depth和Effective library sizes作为标准化主要的方向。  \n\n直接进行标准化：`y = calcNormFactors(y)`  \n![](6.png)  \n\n`norm.factors`发生了变化。  \n\n*We call the product of the original library size and the scaling factor the effective library size. The effective library size replaces the original library size in all downsteam analyses*  \n\n在下面的分析中都是以这个`effective library size`为准。  \n\n`effective library size = original library size * norm.factors`  \n\n### 查找差异基因  \n\n**经典的edgeR分析：**  \n\n*edgeR uses the quantile-adjusted conditional maximum likelihood (qCML) method for experiments with single factor*  \n \n该方法适用于单因子。  \n直接上命令:  \n`y = estimateDisp(y)`  \n`et = exactTest(y)`  \n`topTags(et)`  \n![](7.png)  \n显示的是norm组和cancer组之间的靠前显著基因。  \n如果想要更进一步进行筛选的话，可以按照`et$table`中的四个列进行筛选。  \n如：logFC > 2 并且 p值 < 0.05  \n`ed = et$table[which(et$table$logFC > 2 & et$table$PValue < 0.05),]`  \n\n![](8.png)  \n\n**转换基因名**  \n来源：[https://github.com/twbattaglia/RNAseq-workflow](https://github.com/twbattaglia/RNAseq-workflow)  \n\n`library(org.Hs.eg.db)`  \n`sy = mapIds(x = org.Hs.eg.db,keys = substr(row.names(ed),1,15),keytype = 'ENSEMBL',column = 'SYMBOL',multiVals = 'first')`  \n`ed$symbol = sy`  \n\n*注意事项：转换的时候，ENSGXXXXXXXXXX.XX，需要去除小数点以及小数点后两位的数字。*  \n![](9.png)  \n\n## 后续  \n1.下游分析（GO、KEGG）以及可视化（热图，火山图）。  \n2.原理（长期）。","slug":"EdgeR","published":1,"updated":"2023-02-18T15:20:27.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cleb7c83800041q96b6h37j9e","content":"<h1 id=\"edger查找差异表达基因\"><a class=\"markdownIt-Anchor\" href=\"#edger查找差异表达基因\"></a> EdgeR查找差异表达基因</h1>\n<p>内容主要来源：<br>\n<a href=\"https://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf\">https://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf</a>（官方使用文档)</p>\n<h2 id=\"数据来源\"><a class=\"markdownIt-Anchor\" href=\"#数据来源\"></a> 数据来源</h2>\n<p>癌症细胞：<code>Encode</code>上<code>NCI-H460</code>癌症细胞系<code>total RNA-Seq</code>数据，因为<code>Encode</code>已经给出了基因定量的数据文件，故无需再重复跑一次产出定量文件的流程。<br>\n正常细胞：仍然来自于<code>Encode</code>,选用的正常肺组织的<code>total RNA-Seq</code>的基因定量文件。<br>\n<img src=\"/2021/09/27/EdgeR/1.png\" alt></p>\n<h2 id=\"过程\"><a class=\"markdownIt-Anchor\" href=\"#过程\"></a> 过程</h2>\n<h3 id=\"基因定量信息\"><a class=\"markdownIt-Anchor\" href=\"#基因定量信息\"></a> 基因定量信息</h3>\n<p><em><strong>Files need to contain two columns, one for the counts and one for a gene identifier.</strong></em></p>\n<p>所需的定量文件共两列，一列基因，一列基因的数量。从Encode上下载下来的文件内容是这样的:</p>\n<p><img src=\"/2021/09/27/EdgeR/2.png\" alt></p>\n<p><em><strong>Note that edgeR is designed to work with actual read counts. We not recommend that predicted transcript abundances are input the edgeR in place of actual counts.</strong></em><br>\n根据文档，要求我们使用初始的基因读数，这里使用了<code>gene_id</code>和<code>expected_count</code>两列组成EdgeR的输入数据文件。<br>\n<br><br>\n<strong>读入初始数据:</strong></p>\n<blockquote>\n<p>rep1=read.table(“./NCI-H460.totalRNA.geneQA.rep1.tsv”,header =  TRUE)<br>\nrep2=read.table(“./NCI-H460.totalRNA.geneQA.rep2.tsv”,header =  TRUE)<br>\nnorm1=read.table(“./lung.toalRNA.geneQA.rep1.tsv”,header =  TRUE)<br>\nnorm2=read.table(“./lung.toalRNA.geneQA.rep2.tsv”,header =  TRUE)</p>\n</blockquote>\n<br>\n<p><strong>提取所需两列:</strong></p>\n<blockquote>\n<p>rep1=rep1[,1:5]<br>\nrep1=rep1[,-c(2:4)]</p>\n</blockquote>\n<p>其他rep2、norm1、norm2按照同样操作即可。</p>\n<p><strong>汇成总表：</strong></p>\n<blockquote>\n<p>count=merge(norm1,norm2,by=“gene_id”)<br>\ncolnames(count)=c(“gene_id”,“nomr1”,“norm2”)<br>\ncount=merge(count,rep1,by=‘gene_id’)<br>\ncount=merge(count,rep2,by=‘gene_id’)<br>\ncolnames(count)=c(‘gene_Id’,‘norm1’,‘norm2’,‘rep1’,‘rep2’)<br>\nrow.names(count)=count$gene_Id<br>\ncount=count[,-c(1)]</p>\n</blockquote>\n<p><img src=\"/2021/09/27/EdgeR/3.png\" alt></p>\n<p><strong>转换成DGEList类型：</strong><br>\n分组并转换：</p>\n<blockquote>\n<p>group=c(“norm”,“norm”,“cancer”,“cancer”)<br>\ny=DGEList(counts=count,group = group)</p>\n</blockquote>\n<p><img src=\"/2021/09/27/EdgeR/4.png\" alt><br>\n如图上所示，rep1与rep2的lib.size的差异有点大。重新检查了下，确认并没有下载错误的文件，那么作为试水，继续进行下去吧。</p>\n<p><strong>过滤低表达基因：</strong><br>\n从生物学的角度来看，一个基因必须在某种最低水平上表达，才有可能被翻译成蛋白质或具有生物学上的重要性。此外，这些计数的显著离散性也干扰了后面流程中使用的一些统计近似过程。</p>\n<p><img src=\"/2021/09/27/EdgeR/5.png\" alt></p>\n<p>直接用<code>filterByExpr</code>进行过滤:</p>\n<blockquote>\n<p>keep=filterByExpr(y,group = group)<br>\ny=y[keep,keep.lib.sizes=FALSE]</p>\n</blockquote>\n<p><em>keep应该是逻辑类型的向量，它其中代表的意义是哪些基因应该留下来，哪些基因该被筛选出去，故有第二步，需要根据keep对y做处理，才是真正意义上的筛选。</em></p>\n<h3 id=\"normalization标准化\"><a class=\"markdownIt-Anchor\" href=\"#normalization标准化\"></a> Normalization（标准化)</h3>\n<p>此时y中的样本之间仍然无法进行比较，样本的表达量是在相对不同的条件下测得的，而我们又恰恰需要观察样本之间本身的差异，需要将它们标准化。<br>\nEdgeR标准化没有将基因长度和GC含量作为主要因素，它把Sequencing depth和Effective library sizes作为标准化主要的方向。</p>\n<p>直接进行标准化：<code>y = calcNormFactors(y)</code><br>\n<img src=\"/2021/09/27/EdgeR/6.png\" alt></p>\n<p><code>norm.factors</code>发生了变化。</p>\n<p><em>We call the product of the original library size and the scaling factor the effective library size. The effective library size replaces the original library size in all downsteam analyses</em></p>\n<p>在下面的分析中都是以这个<code>effective library size</code>为准。</p>\n<p><code>effective library size = original library size * norm.factors</code></p>\n<h3 id=\"查找差异基因\"><a class=\"markdownIt-Anchor\" href=\"#查找差异基因\"></a> 查找差异基因</h3>\n<p><strong>经典的edgeR分析：</strong></p>\n<p><em>edgeR uses the quantile-adjusted conditional maximum likelihood (qCML) method for experiments with single factor</em></p>\n<p>该方法适用于单因子。<br>\n直接上命令:<br>\n<code>y = estimateDisp(y)</code><br>\n<code>et = exactTest(y)</code><br>\n<code>topTags(et)</code><br>\n<img src=\"/2021/09/27/EdgeR/7.png\" alt><br>\n显示的是norm组和cancer组之间的靠前显著基因。<br>\n如果想要更进一步进行筛选的话，可以按照<code>et$table</code>中的四个列进行筛选。<br>\n如：logFC &gt; 2 并且 p值 &lt; 0.05<br>\n<code>ed = et$table[which(et$table$logFC &gt; 2 &amp; et$table$PValue &lt; 0.05),]</code></p>\n<p><img src=\"/2021/09/27/EdgeR/8.png\" alt></p>\n<p><strong>转换基因名</strong><br>\n来源：<a href=\"https://github.com/twbattaglia/RNAseq-workflow\">https://github.com/twbattaglia/RNAseq-workflow</a></p>\n<p><code>library(org.Hs.eg.db)</code><br>\n<code>sy = mapIds(x = org.Hs.eg.db,keys = substr(row.names(ed),1,15),keytype = 'ENSEMBL',column = 'SYMBOL',multiVals = 'first')</code><br>\n<code>ed$symbol = sy</code></p>\n<p><em>注意事项：转换的时候，ENSGXXXXXXXXXX.XX，需要去除小数点以及小数点后两位的数字。</em><br>\n<img src=\"/2021/09/27/EdgeR/9.png\" alt></p>\n<h2 id=\"后续\"><a class=\"markdownIt-Anchor\" href=\"#后续\"></a> 后续</h2>\n<p>1.下游分析（GO、KEGG）以及可视化（热图，火山图）。<br>\n2.原理（长期）。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"edger查找差异表达基因\"><a class=\"markdownIt-Anchor\" href=\"#edger查找差异表达基因\"></a> EdgeR查找差异表达基因</h1>\n<p>内容主要来源：<br>\n<a href=\"https://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf\">https://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf</a>（官方使用文档)</p>\n<h2 id=\"数据来源\"><a class=\"markdownIt-Anchor\" href=\"#数据来源\"></a> 数据来源</h2>\n<p>癌症细胞：<code>Encode</code>上<code>NCI-H460</code>癌症细胞系<code>total RNA-Seq</code>数据，因为<code>Encode</code>已经给出了基因定量的数据文件，故无需再重复跑一次产出定量文件的流程。<br>\n正常细胞：仍然来自于<code>Encode</code>,选用的正常肺组织的<code>total RNA-Seq</code>的基因定量文件。<br>\n<img src=\"/2021/09/27/EdgeR/1.png\" alt></p>\n<h2 id=\"过程\"><a class=\"markdownIt-Anchor\" href=\"#过程\"></a> 过程</h2>\n<h3 id=\"基因定量信息\"><a class=\"markdownIt-Anchor\" href=\"#基因定量信息\"></a> 基因定量信息</h3>\n<p><em><strong>Files need to contain two columns, one for the counts and one for a gene identifier.</strong></em></p>\n<p>所需的定量文件共两列，一列基因，一列基因的数量。从Encode上下载下来的文件内容是这样的:</p>\n<p><img src=\"/2021/09/27/EdgeR/2.png\" alt></p>\n<p><em><strong>Note that edgeR is designed to work with actual read counts. We not recommend that predicted transcript abundances are input the edgeR in place of actual counts.</strong></em><br>\n根据文档，要求我们使用初始的基因读数，这里使用了<code>gene_id</code>和<code>expected_count</code>两列组成EdgeR的输入数据文件。<br>\n<br><br>\n<strong>读入初始数据:</strong></p>\n<blockquote>\n<p>rep1=read.table(“./NCI-H460.totalRNA.geneQA.rep1.tsv”,header =  TRUE)<br>\nrep2=read.table(“./NCI-H460.totalRNA.geneQA.rep2.tsv”,header =  TRUE)<br>\nnorm1=read.table(“./lung.toalRNA.geneQA.rep1.tsv”,header =  TRUE)<br>\nnorm2=read.table(“./lung.toalRNA.geneQA.rep2.tsv”,header =  TRUE)</p>\n</blockquote>\n<br>\n<p><strong>提取所需两列:</strong></p>\n<blockquote>\n<p>rep1=rep1[,1:5]<br>\nrep1=rep1[,-c(2:4)]</p>\n</blockquote>\n<p>其他rep2、norm1、norm2按照同样操作即可。</p>\n<p><strong>汇成总表：</strong></p>\n<blockquote>\n<p>count=merge(norm1,norm2,by=“gene_id”)<br>\ncolnames(count)=c(“gene_id”,“nomr1”,“norm2”)<br>\ncount=merge(count,rep1,by=‘gene_id’)<br>\ncount=merge(count,rep2,by=‘gene_id’)<br>\ncolnames(count)=c(‘gene_Id’,‘norm1’,‘norm2’,‘rep1’,‘rep2’)<br>\nrow.names(count)=count$gene_Id<br>\ncount=count[,-c(1)]</p>\n</blockquote>\n<p><img src=\"/2021/09/27/EdgeR/3.png\" alt></p>\n<p><strong>转换成DGEList类型：</strong><br>\n分组并转换：</p>\n<blockquote>\n<p>group=c(“norm”,“norm”,“cancer”,“cancer”)<br>\ny=DGEList(counts=count,group = group)</p>\n</blockquote>\n<p><img src=\"/2021/09/27/EdgeR/4.png\" alt><br>\n如图上所示，rep1与rep2的lib.size的差异有点大。重新检查了下，确认并没有下载错误的文件，那么作为试水，继续进行下去吧。</p>\n<p><strong>过滤低表达基因：</strong><br>\n从生物学的角度来看，一个基因必须在某种最低水平上表达，才有可能被翻译成蛋白质或具有生物学上的重要性。此外，这些计数的显著离散性也干扰了后面流程中使用的一些统计近似过程。</p>\n<p><img src=\"/2021/09/27/EdgeR/5.png\" alt></p>\n<p>直接用<code>filterByExpr</code>进行过滤:</p>\n<blockquote>\n<p>keep=filterByExpr(y,group = group)<br>\ny=y[keep,keep.lib.sizes=FALSE]</p>\n</blockquote>\n<p><em>keep应该是逻辑类型的向量，它其中代表的意义是哪些基因应该留下来，哪些基因该被筛选出去，故有第二步，需要根据keep对y做处理，才是真正意义上的筛选。</em></p>\n<h3 id=\"normalization标准化\"><a class=\"markdownIt-Anchor\" href=\"#normalization标准化\"></a> Normalization（标准化)</h3>\n<p>此时y中的样本之间仍然无法进行比较，样本的表达量是在相对不同的条件下测得的，而我们又恰恰需要观察样本之间本身的差异，需要将它们标准化。<br>\nEdgeR标准化没有将基因长度和GC含量作为主要因素，它把Sequencing depth和Effective library sizes作为标准化主要的方向。</p>\n<p>直接进行标准化：<code>y = calcNormFactors(y)</code><br>\n<img src=\"/2021/09/27/EdgeR/6.png\" alt></p>\n<p><code>norm.factors</code>发生了变化。</p>\n<p><em>We call the product of the original library size and the scaling factor the effective library size. The effective library size replaces the original library size in all downsteam analyses</em></p>\n<p>在下面的分析中都是以这个<code>effective library size</code>为准。</p>\n<p><code>effective library size = original library size * norm.factors</code></p>\n<h3 id=\"查找差异基因\"><a class=\"markdownIt-Anchor\" href=\"#查找差异基因\"></a> 查找差异基因</h3>\n<p><strong>经典的edgeR分析：</strong></p>\n<p><em>edgeR uses the quantile-adjusted conditional maximum likelihood (qCML) method for experiments with single factor</em></p>\n<p>该方法适用于单因子。<br>\n直接上命令:<br>\n<code>y = estimateDisp(y)</code><br>\n<code>et = exactTest(y)</code><br>\n<code>topTags(et)</code><br>\n<img src=\"/2021/09/27/EdgeR/7.png\" alt><br>\n显示的是norm组和cancer组之间的靠前显著基因。<br>\n如果想要更进一步进行筛选的话，可以按照<code>et$table</code>中的四个列进行筛选。<br>\n如：logFC &gt; 2 并且 p值 &lt; 0.05<br>\n<code>ed = et$table[which(et$table$logFC &gt; 2 &amp; et$table$PValue &lt; 0.05),]</code></p>\n<p><img src=\"/2021/09/27/EdgeR/8.png\" alt></p>\n<p><strong>转换基因名</strong><br>\n来源：<a href=\"https://github.com/twbattaglia/RNAseq-workflow\">https://github.com/twbattaglia/RNAseq-workflow</a></p>\n<p><code>library(org.Hs.eg.db)</code><br>\n<code>sy = mapIds(x = org.Hs.eg.db,keys = substr(row.names(ed),1,15),keytype = 'ENSEMBL',column = 'SYMBOL',multiVals = 'first')</code><br>\n<code>ed$symbol = sy</code></p>\n<p><em>注意事项：转换的时候，ENSGXXXXXXXXXX.XX，需要去除小数点以及小数点后两位的数字。</em><br>\n<img src=\"/2021/09/27/EdgeR/9.png\" alt></p>\n<h2 id=\"后续\"><a class=\"markdownIt-Anchor\" href=\"#后续\"></a> 后续</h2>\n<p>1.下游分析（GO、KEGG）以及可视化（热图，火山图）。<br>\n2.原理（长期）。</p>\n"},{"title":"Hexo博客插入图片","date":"2021-09-24T13:08:49.000Z","_content":"# Hexo博客插入图片问题  \n*推送博客时遇到一个问题，图片无法顺利在网站中展现。*  \n百度解决方法，内容来源：[https://zhuanlan.zhihu.com/p/265077468](https://zhuanlan.zhihu.com/p/265077468)  \n[https://hexo.io/zh-cn/docs/asset-folders](https://hexo.io/zh-cn/docs/asset-folders)     \n**在md文件中只需要`![]()`并在`()`中填写本地图片路径，图片即可插入。**  \n\n***解决办法：***  \n1. 在`_congfig.yaml`文件中将`post_asset_folder: false`改为`post_asset_folder: true`。  \n\n> 由于项目会生成新的文件目录，同时会解析Markdown中的图片路径，会导致一个问题。\n> 如在一个文件目录下，博客名为1.md，相应的存在一个1文件夹存放图片image.jpg。\n> 在Typora编辑器中，普通的md文件使用`![](1/image.jpg)`能在编辑器中正常显示图片。\n> 在hexo中，按理说应该是使用`![](image.jpg)`，但网页中却无法正常显示。\n> 此时应该使用这样的方式来引入图片:`{% asset_img image.jpg 这是一张图片 %} `  \n2.解决`{% asset_img image.jpg 这是一张图片 %} `这种难写的语法。`npm install hexo-renderer-marked`安装插件，并在`_config.yaml`中更改配置:  \n\n>post_asset_folder: true  \n>marked:  \n>prependRoot: true  \n>postAsset: true  \n\n3.如果采用`![](image.jpg)`的方式，此时md文件和相应图片处于同一目录下，但是直接上传仍然无法成功在网站上插入图片，而是需要将md文件拿到上级目录，像这样  \n![](insert.png)  \n如此的话，我们编写的时候可将md文件置于同一文件夹，编写完成时需将md文件拿到上级目录即可。  ","source":"_posts/InsertImageinHexo.md","raw":"---\ntitle: Hexo博客插入图片\ndate: 2021-09-24 21:08:49\ncategories: \n- Blog\ntags: \n- Blog\n---\n# Hexo博客插入图片问题  \n*推送博客时遇到一个问题，图片无法顺利在网站中展现。*  \n百度解决方法，内容来源：[https://zhuanlan.zhihu.com/p/265077468](https://zhuanlan.zhihu.com/p/265077468)  \n[https://hexo.io/zh-cn/docs/asset-folders](https://hexo.io/zh-cn/docs/asset-folders)     \n**在md文件中只需要`![]()`并在`()`中填写本地图片路径，图片即可插入。**  \n\n***解决办法：***  \n1. 在`_congfig.yaml`文件中将`post_asset_folder: false`改为`post_asset_folder: true`。  \n\n> 由于项目会生成新的文件目录，同时会解析Markdown中的图片路径，会导致一个问题。\n> 如在一个文件目录下，博客名为1.md，相应的存在一个1文件夹存放图片image.jpg。\n> 在Typora编辑器中，普通的md文件使用`![](1/image.jpg)`能在编辑器中正常显示图片。\n> 在hexo中，按理说应该是使用`![](image.jpg)`，但网页中却无法正常显示。\n> 此时应该使用这样的方式来引入图片:`{% asset_img image.jpg 这是一张图片 %} `  \n2.解决`{% asset_img image.jpg 这是一张图片 %} `这种难写的语法。`npm install hexo-renderer-marked`安装插件，并在`_config.yaml`中更改配置:  \n\n>post_asset_folder: true  \n>marked:  \n>prependRoot: true  \n>postAsset: true  \n\n3.如果采用`![](image.jpg)`的方式，此时md文件和相应图片处于同一目录下，但是直接上传仍然无法成功在网站上插入图片，而是需要将md文件拿到上级目录，像这样  \n![](insert.png)  \n如此的话，我们编写的时候可将md文件置于同一文件夹，编写完成时需将md文件拿到上级目录即可。  ","slug":"InsertImageinHexo","published":1,"updated":"2023-02-18T15:19:07.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cleb7c83900051q96a6yc6ens","content":"<h1 id=\"hexo博客插入图片问题\"><a class=\"markdownIt-Anchor\" href=\"#hexo博客插入图片问题\"></a> Hexo博客插入图片问题</h1>\n<p><em>推送博客时遇到一个问题，图片无法顺利在网站中展现。</em><br>\n百度解决方法，内容来源：<a href=\"https://zhuanlan.zhihu.com/p/265077468\">https://zhuanlan.zhihu.com/p/265077468</a><br>\n<a href=\"https://hexo.io/zh-cn/docs/asset-folders\">https://hexo.io/zh-cn/docs/asset-folders</a><br>\n<strong>在md文件中只需要<code>![]()</code>并在<code>()</code>中填写本地图片路径，图片即可插入。</strong></p>\n<p><em><strong>解决办法：</strong></em></p>\n<ol>\n<li>在<code>_congfig.yaml</code>文件中将<code>post_asset_folder: false</code>改为<code>post_asset_folder: true</code>。</li>\n</ol>\n<blockquote>\n<p>由于项目会生成新的文件目录，同时会解析Markdown中的图片路径，会导致一个问题。<br>\n如在一个文件目录下，<a href=\"http://xn--1-br6ax7nqua970a.md\">博客名为1.md</a>，相应的存在一个1文件夹存放图片image.jpg。<br>\n在Typora编辑器中，普通的md文件使用<code>&#123;% asset_img \"image.jpg\" \"\" %&#125;</code>能在编辑器中正常显示图片。<br>\n在hexo中，按理说应该是使用<code>![](image.jpg)</code>，但网页中却无法正常显示。<br>\n此时应该使用这样的方式来引入图片:<code>&#123;% asset_img image.jpg 这是一张图片 %&#125; </code><br>\n2.解决<code>&#123;% asset_img image.jpg 这是一张图片 %&#125; </code>这种难写的语法。<code>npm install hexo-renderer-marked</code>安装插件，并在<code>_config.yaml</code>中更改配置:</p>\n</blockquote>\n<blockquote>\n<p>post_asset_folder: true<br>\nmarked:<br>\nprependRoot: true<br>\npostAsset: true</p>\n</blockquote>\n<p>3.如果采用<code>![](image.jpg)</code>的方式，此时md文件和相应图片处于同一目录下，但是直接上传仍然无法成功在网站上插入图片，而是需要将md文件拿到上级目录，像这样<br>\n<img src=\"/2021/09/24/InsertImageinHexo/insert.png\" alt><br>\n如此的话，我们编写的时候可将md文件置于同一文件夹，编写完成时需将md文件拿到上级目录即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"hexo博客插入图片问题\"><a class=\"markdownIt-Anchor\" href=\"#hexo博客插入图片问题\"></a> Hexo博客插入图片问题</h1>\n<p><em>推送博客时遇到一个问题，图片无法顺利在网站中展现。</em><br>\n百度解决方法，内容来源：<a href=\"https://zhuanlan.zhihu.com/p/265077468\">https://zhuanlan.zhihu.com/p/265077468</a><br>\n<a href=\"https://hexo.io/zh-cn/docs/asset-folders\">https://hexo.io/zh-cn/docs/asset-folders</a><br>\n<strong>在md文件中只需要<code>![]()</code>并在<code>()</code>中填写本地图片路径，图片即可插入。</strong></p>\n<p><em><strong>解决办法：</strong></em></p>\n<ol>\n<li>在<code>_congfig.yaml</code>文件中将<code>post_asset_folder: false</code>改为<code>post_asset_folder: true</code>。</li>\n</ol>\n<blockquote>\n<p>由于项目会生成新的文件目录，同时会解析Markdown中的图片路径，会导致一个问题。<br>\n如在一个文件目录下，<a href=\"http://xn--1-br6ax7nqua970a.md\">博客名为1.md</a>，相应的存在一个1文件夹存放图片image.jpg。<br>\n在Typora编辑器中，普通的md文件使用<code>&#123;% asset_img \"image.jpg\" \"\" %&#125;</code>能在编辑器中正常显示图片。<br>\n在hexo中，按理说应该是使用<code>![](image.jpg)</code>，但网页中却无法正常显示。<br>\n此时应该使用这样的方式来引入图片:<code>&#123;% asset_img image.jpg 这是一张图片 %&#125; </code><br>\n2.解决<code>&#123;% asset_img image.jpg 这是一张图片 %&#125; </code>这种难写的语法。<code>npm install hexo-renderer-marked</code>安装插件，并在<code>_config.yaml</code>中更改配置:</p>\n</blockquote>\n<blockquote>\n<p>post_asset_folder: true<br>\nmarked:<br>\nprependRoot: true<br>\npostAsset: true</p>\n</blockquote>\n<p>3.如果采用<code>![](image.jpg)</code>的方式，此时md文件和相应图片处于同一目录下，但是直接上传仍然无法成功在网站上插入图片，而是需要将md文件拿到上级目录，像这样<br>\n<img src=\"/2021/09/24/InsertImageinHexo/insert.png\" alt><br>\n如此的话，我们编写的时候可将md文件置于同一文件夹，编写完成时需将md文件拿到上级目录即可。</p>\n"},{"title":"EdgeR原理探究","date":"2021-09-26T16:00:00.000Z","toc":true,"_content":"## 负二项分布模型\nEdgeR包使用了负二项分布来对各个样本中的基因表达进行分析。  \n> 负二项分布描述的是第r次成功前失败的次数。一个成功概率为p的伯努利试验，不断重复，直至失败r次。此时成功的次数为一个随机变量，用$X$表示。称$X$服从二项分布，记作$X \\sim NB(r,p)$  \n\n为什么EdgeR作者将总的样本中的基因读数认作是服从负二项分布的呢？  \n![](2.png)  \n从手册中可知，原因有2个。一个是所谓的BCV值重要性比真实的基因丰度概率分布更重要。另一个是作者假定了基因丰度服从了伽马分布。  \n\n### Biological coefficient of variation（BCV）  \n这个所谓的BCV，便是生物变异系数，按照手册中的定义，假设我们有$i$个样本（有着多种分组），而对于单独一个样本而言，可测得总的基因$G$的读取数。这样我们也可知道第$i$个样本中第$g$个的读取数占这个样本所有读取数的多少（百分数），记做$\\pi_{gi}$，而将所有基因所占的部分加起来肯定等于1，则有$\\sum_{g=1}^G \\pi_{gi} = 1$。  \n\n## model\nEdgeR包采用了两种统计学方法，一种是所谓的精确统计，另一种是基于广义线性模型（glm）的统计。从官方文档来看，官方更为推崇glm。  \n这两种方法都采用了经验贝叶斯方法来估计特定基因的生物变异。  \n![](1.png)  \n\n","source":"_posts/PrincipleOfEdgeR.md","raw":"---\ntitle: EdgeR原理探究\ndate: 2021-09-27\ntoc: true\ncategories: \n- Bioinformatics\ntags: \n- RNA-Seq\n- DE-Analysis\n---\n## 负二项分布模型\nEdgeR包使用了负二项分布来对各个样本中的基因表达进行分析。  \n> 负二项分布描述的是第r次成功前失败的次数。一个成功概率为p的伯努利试验，不断重复，直至失败r次。此时成功的次数为一个随机变量，用$X$表示。称$X$服从二项分布，记作$X \\sim NB(r,p)$  \n\n为什么EdgeR作者将总的样本中的基因读数认作是服从负二项分布的呢？  \n![](2.png)  \n从手册中可知，原因有2个。一个是所谓的BCV值重要性比真实的基因丰度概率分布更重要。另一个是作者假定了基因丰度服从了伽马分布。  \n\n### Biological coefficient of variation（BCV）  \n这个所谓的BCV，便是生物变异系数，按照手册中的定义，假设我们有$i$个样本（有着多种分组），而对于单独一个样本而言，可测得总的基因$G$的读取数。这样我们也可知道第$i$个样本中第$g$个的读取数占这个样本所有读取数的多少（百分数），记做$\\pi_{gi}$，而将所有基因所占的部分加起来肯定等于1，则有$\\sum_{g=1}^G \\pi_{gi} = 1$。  \n\n## model\nEdgeR包采用了两种统计学方法，一种是所谓的精确统计，另一种是基于广义线性模型（glm）的统计。从官方文档来看，官方更为推崇glm。  \n这两种方法都采用了经验贝叶斯方法来估计特定基因的生物变异。  \n![](1.png)  \n\n","slug":"PrincipleOfEdgeR","published":1,"updated":"2023-02-18T15:19:22.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cleb7c83a00061q962lzsgk89","content":"<h2 id=\"负二项分布模型\"><a class=\"markdownIt-Anchor\" href=\"#负二项分布模型\"></a> 负二项分布模型</h2>\n<p>EdgeR包使用了负二项分布来对各个样本中的基因表达进行分析。</p>\n<blockquote>\n<p>负二项分布描述的是第r次成功前失败的次数。一个成功概率为p的伯努利试验，不断重复，直至失败r次。此时成功的次数为一个随机变量，用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>表示。称<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>服从二项分布，记作<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>∼</mo><mi>N</mi><mi>B</mi><mo stretchy=\"false\">(</mo><mi>r</mi><mo separator=\"true\">,</mo><mi>p</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">X \\sim NB(r,p)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">)</span></span></span></span></p>\n</blockquote>\n<p>为什么EdgeR作者将总的样本中的基因读数认作是服从负二项分布的呢？<br>\n<img src=\"/2021/09/27/PrincipleOfEdgeR/2.png\" alt><br>\n从手册中可知，原因有2个。一个是所谓的BCV值重要性比真实的基因丰度概率分布更重要。另一个是作者假定了基因丰度服从了伽马分布。</p>\n<h3 id=\"biological-coefficient-of-variationbcv\"><a class=\"markdownIt-Anchor\" href=\"#biological-coefficient-of-variationbcv\"></a> Biological coefficient of variation（BCV）</h3>\n<p>这个所谓的BCV，便是生物变异系数，按照手册中的定义，假设我们有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>个样本（有着多种分组），而对于单独一个样本而言，可测得总的基因<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>的读取数。这样我们也可知道第<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>个样本中第<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span>个的读取数占这个样本所有读取数的多少（百分数），记做<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>π</mi><mrow><mi>g</mi><mi>i</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\pi_{gi}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>，而将所有基因所占的部分加起来肯定等于1，则有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>g</mi><mo>=</mo><mn>1</mn></mrow><mi>G</mi></msubsup><msub><mi>π</mi><mrow><mi>g</mi><mi>i</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\sum_{g=1}^G \\pi_{gi} = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.417049em;vertical-align:-0.43581800000000004em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.981231em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">G</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.43581800000000004em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>。</p>\n<h2 id=\"model\"><a class=\"markdownIt-Anchor\" href=\"#model\"></a> model</h2>\n<p>EdgeR包采用了两种统计学方法，一种是所谓的精确统计，另一种是基于广义线性模型（glm）的统计。从官方文档来看，官方更为推崇glm。<br>\n这两种方法都采用了经验贝叶斯方法来估计特定基因的生物变异。<br>\n<img src=\"/2021/09/27/PrincipleOfEdgeR/1.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"负二项分布模型\"><a class=\"markdownIt-Anchor\" href=\"#负二项分布模型\"></a> 负二项分布模型</h2>\n<p>EdgeR包使用了负二项分布来对各个样本中的基因表达进行分析。</p>\n<blockquote>\n<p>负二项分布描述的是第r次成功前失败的次数。一个成功概率为p的伯努利试验，不断重复，直至失败r次。此时成功的次数为一个随机变量，用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>表示。称<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>服从二项分布，记作<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>∼</mo><mi>N</mi><mi>B</mi><mo stretchy=\"false\">(</mo><mi>r</mi><mo separator=\"true\">,</mo><mi>p</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">X \\sim NB(r,p)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∼</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">)</span></span></span></span></p>\n</blockquote>\n<p>为什么EdgeR作者将总的样本中的基因读数认作是服从负二项分布的呢？<br>\n<img src=\"/2021/09/27/PrincipleOfEdgeR/2.png\" alt><br>\n从手册中可知，原因有2个。一个是所谓的BCV值重要性比真实的基因丰度概率分布更重要。另一个是作者假定了基因丰度服从了伽马分布。</p>\n<h3 id=\"biological-coefficient-of-variationbcv\"><a class=\"markdownIt-Anchor\" href=\"#biological-coefficient-of-variationbcv\"></a> Biological coefficient of variation（BCV）</h3>\n<p>这个所谓的BCV，便是生物变异系数，按照手册中的定义，假设我们有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>个样本（有着多种分组），而对于单独一个样本而言，可测得总的基因<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>的读取数。这样我们也可知道第<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>个样本中第<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span>个的读取数占这个样本所有读取数的多少（百分数），记做<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>π</mi><mrow><mi>g</mi><mi>i</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\pi_{gi}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.716668em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>，而将所有基因所占的部分加起来肯定等于1，则有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>g</mi><mo>=</mo><mn>1</mn></mrow><mi>G</mi></msubsup><msub><mi>π</mi><mrow><mi>g</mi><mi>i</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\sum_{g=1}^G \\pi_{gi} = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.417049em;vertical-align:-0.43581800000000004em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.981231em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">G</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.43581800000000004em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal mtight\">i</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>。</p>\n<h2 id=\"model\"><a class=\"markdownIt-Anchor\" href=\"#model\"></a> model</h2>\n<p>EdgeR包采用了两种统计学方法，一种是所谓的精确统计，另一种是基于广义线性模型（glm）的统计。从官方文档来看，官方更为推崇glm。<br>\n这两种方法都采用了经验贝叶斯方法来估计特定基因的生物变异。<br>\n<img src=\"/2021/09/27/PrincipleOfEdgeR/1.png\" alt></p>\n"},{"title":"clusterProfiler进行GO、KEGG以及相应的可视化","date":"2021-10-08T16:00:00.000Z","_content":"# clusterProfiler进行GO、KEGG以及相应的可视化  \n内容主要来源：  \n[https://guangchuangyu.github.io/softwaredocumentation/](https://guangchuangyu.github.io/softwaredocumentation/)（官方使用文档)  \n## 数据来源  \n**差异基因列表：**`NCI-H460`癌症细胞同正常组织之间的差异基因。  \n承接自这篇笔记中:[EdgeR查找差异表达基因](https://tanzhengtang.github.io/2021/09/27/EdgeR/)  \n\n## 过程  \n### GO分析  \n**代码:**  \n`ego <- enrichGO(gene = idt,OrgDb = org.Hs.eg.db,keyType = 'ENSEMBL',ont = \"ALL\",pAdjustMethod = \"BH\",pvalueCutoff = 0.01,qvalueCutoff  = 0.05,readable = T)`  \n**gene是得到的差异基因列表.  \nkeyType指定基因ID的类型,默认为ENTREZID.  \nOrgDb指定该物种对应的org包的名字.  \nont代表GO的3大类别，BP, CC, MF,而ALL是将该3类一起包含.  \npAdjustMethod指定多重假设检验矫正的方法.  \ncufoff指定对应的阈值.  \nreadable=TRUE将基因ID转换为gene symbol.**  \n_idt_ 差异基因列表:  \n![](1.png)  \n这样就可以直接出图了。  \n`dotplot(ego,showCategory = 10)`   \n![](2.png)   \n`barplot(ego,showCategory = 10)`  \n![](3.png)  \n\n### KEGG分析  \n在代码方面同GO分析差不多:  \n`kk=enrichKEGG(te$entrzid,organism=\"hsa\",\npvalueCutoff=0.05,pAdjustMethod=\"BH\",qvalueCutoff=0.1)`  \n`kk=setReadable(kk,OrgDb = org.Hs.eg.db,keyType = 'ENTREZID')`  \n经尝试，KEGG分析似乎不支持ENSEMBL的ID，所以运行上面之前先转换成ENTRZID:  \n`en=mapIds(x = org.Hs.eg.db,keys = ed$symbol,keytype = \"SYMBOL\",column = \"ENTREZID\")`  \n`ed$entrzid=en`  \n`te=na.omit(ed)`  \n出图：  \n`barplot(kk,ddrop=T,showCategory =10,title=\"KEGG Enrichment Pathways\")`  \n![](4.png)  \n\n**额外的pathview图：**  \n内容来源:  \n[https://cloud.tencent.com/developer/article/1539928](https://cloud.tencent.com/developer/article/1539928)  \n`genem=tee$logFC`  \n`names(genem)=row.names(tee)`  \n`pathview(gene.data = genem,pathway.id = '04514',species = 'hsa')`  \n`pathway.id`是信号通路的id，如04514意味着Cell adhesion molecules通路，画出的是该样本在某通路上的基因表达量变化。  \n`gene.data`是样本的表达量，这个可以是foldchange,也可以是cpm等等。   \n`genem`的行名须是ENTRZID.  \n`species`是种类。  \n![](5.png)  \n\n## 后续\n1.原理（长期）。","source":"_posts/clusterProfiler.md","raw":"---\ntitle: clusterProfiler进行GO、KEGG以及相应的可视化\ndate: 2021-10-09\ncategories: \n- Bioinformatics\ntags: \n- RNA-Seq\n- DE-Analysis\n---\n# clusterProfiler进行GO、KEGG以及相应的可视化  \n内容主要来源：  \n[https://guangchuangyu.github.io/softwaredocumentation/](https://guangchuangyu.github.io/softwaredocumentation/)（官方使用文档)  \n## 数据来源  \n**差异基因列表：**`NCI-H460`癌症细胞同正常组织之间的差异基因。  \n承接自这篇笔记中:[EdgeR查找差异表达基因](https://tanzhengtang.github.io/2021/09/27/EdgeR/)  \n\n## 过程  \n### GO分析  \n**代码:**  \n`ego <- enrichGO(gene = idt,OrgDb = org.Hs.eg.db,keyType = 'ENSEMBL',ont = \"ALL\",pAdjustMethod = \"BH\",pvalueCutoff = 0.01,qvalueCutoff  = 0.05,readable = T)`  \n**gene是得到的差异基因列表.  \nkeyType指定基因ID的类型,默认为ENTREZID.  \nOrgDb指定该物种对应的org包的名字.  \nont代表GO的3大类别，BP, CC, MF,而ALL是将该3类一起包含.  \npAdjustMethod指定多重假设检验矫正的方法.  \ncufoff指定对应的阈值.  \nreadable=TRUE将基因ID转换为gene symbol.**  \n_idt_ 差异基因列表:  \n![](1.png)  \n这样就可以直接出图了。  \n`dotplot(ego,showCategory = 10)`   \n![](2.png)   \n`barplot(ego,showCategory = 10)`  \n![](3.png)  \n\n### KEGG分析  \n在代码方面同GO分析差不多:  \n`kk=enrichKEGG(te$entrzid,organism=\"hsa\",\npvalueCutoff=0.05,pAdjustMethod=\"BH\",qvalueCutoff=0.1)`  \n`kk=setReadable(kk,OrgDb = org.Hs.eg.db,keyType = 'ENTREZID')`  \n经尝试，KEGG分析似乎不支持ENSEMBL的ID，所以运行上面之前先转换成ENTRZID:  \n`en=mapIds(x = org.Hs.eg.db,keys = ed$symbol,keytype = \"SYMBOL\",column = \"ENTREZID\")`  \n`ed$entrzid=en`  \n`te=na.omit(ed)`  \n出图：  \n`barplot(kk,ddrop=T,showCategory =10,title=\"KEGG Enrichment Pathways\")`  \n![](4.png)  \n\n**额外的pathview图：**  \n内容来源:  \n[https://cloud.tencent.com/developer/article/1539928](https://cloud.tencent.com/developer/article/1539928)  \n`genem=tee$logFC`  \n`names(genem)=row.names(tee)`  \n`pathview(gene.data = genem,pathway.id = '04514',species = 'hsa')`  \n`pathway.id`是信号通路的id，如04514意味着Cell adhesion molecules通路，画出的是该样本在某通路上的基因表达量变化。  \n`gene.data`是样本的表达量，这个可以是foldchange,也可以是cpm等等。   \n`genem`的行名须是ENTRZID.  \n`species`是种类。  \n![](5.png)  \n\n## 后续\n1.原理（长期）。","slug":"clusterProfiler","published":1,"updated":"2023-02-18T15:20:46.409Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cleb7c83b000a1q969o5u6nlv","content":"<h1 id=\"clusterprofiler进行go-kegg以及相应的可视化\"><a class=\"markdownIt-Anchor\" href=\"#clusterprofiler进行go-kegg以及相应的可视化\"></a> clusterProfiler进行GO、KEGG以及相应的可视化</h1>\n<p>内容主要来源：<br>\n<a href=\"https://guangchuangyu.github.io/softwaredocumentation/\">https://guangchuangyu.github.io/softwaredocumentation/</a>（官方使用文档)</p>\n<h2 id=\"数据来源\"><a class=\"markdownIt-Anchor\" href=\"#数据来源\"></a> 数据来源</h2>\n<p><strong>差异基因列表：</strong><code>NCI-H460</code>癌症细胞同正常组织之间的差异基因。<br>\n承接自这篇笔记中:<a href=\"https://tanzhengtang.github.io/2021/09/27/EdgeR/\">EdgeR查找差异表达基因</a></p>\n<h2 id=\"过程\"><a class=\"markdownIt-Anchor\" href=\"#过程\"></a> 过程</h2>\n<h3 id=\"go分析\"><a class=\"markdownIt-Anchor\" href=\"#go分析\"></a> GO分析</h3>\n<p><strong>代码:</strong><br>\n<code>ego &lt;- enrichGO(gene = idt,OrgDb = org.Hs.eg.db,keyType = 'ENSEMBL',ont = &quot;ALL&quot;,pAdjustMethod = &quot;BH&quot;,pvalueCutoff = 0.01,qvalueCutoff  = 0.05,readable = T)</code><br>\n<strong>gene是得到的差异基因列表.<br>\nkeyType指定基因ID的类型,默认为ENTREZID.<br>\nOrgDb指定该物种对应的org包的名字.<br>\nont代表GO的3大类别，BP, CC, MF,而ALL是将该3类一起包含.<br>\npAdjustMethod指定多重假设检验矫正的方法.<br>\ncufoff指定对应的阈值.<br>\nreadable=TRUE将基因ID转换为gene symbol.</strong><br>\n<em>idt</em> 差异基因列表:<br>\n<img src=\"/2021/10/09/clusterProfiler/1.png\" alt><br>\n这样就可以直接出图了。<br>\n<code>dotplot(ego,showCategory = 10)</code><br>\n<img src=\"/2021/10/09/clusterProfiler/2.png\" alt><br>\n<code>barplot(ego,showCategory = 10)</code><br>\n<img src=\"/2021/10/09/clusterProfiler/3.png\" alt></p>\n<h3 id=\"kegg分析\"><a class=\"markdownIt-Anchor\" href=\"#kegg分析\"></a> KEGG分析</h3>\n<p>在代码方面同GO分析差不多:<br>\n<code>kk=enrichKEGG(te$entrzid,organism=&quot;hsa&quot;, pvalueCutoff=0.05,pAdjustMethod=&quot;BH&quot;,qvalueCutoff=0.1)</code><br>\n<code>kk=setReadable(kk,OrgDb = org.Hs.eg.db,keyType = 'ENTREZID')</code><br>\n经尝试，KEGG分析似乎不支持ENSEMBL的ID，所以运行上面之前先转换成ENTRZID:<br>\n<code>en=mapIds(x = org.Hs.eg.db,keys = ed$symbol,keytype = &quot;SYMBOL&quot;,column = &quot;ENTREZID&quot;)</code><br>\n<code>ed$entrzid=en</code><br>\n<code>te=na.omit(ed)</code><br>\n出图：<br>\n<code>barplot(kk,ddrop=T,showCategory =10,title=&quot;KEGG Enrichment Pathways&quot;)</code><br>\n<img src=\"/2021/10/09/clusterProfiler/4.png\" alt></p>\n<p><strong>额外的pathview图：</strong><br>\n内容来源:<br>\n<a href=\"https://cloud.tencent.com/developer/article/1539928\">https://cloud.tencent.com/developer/article/1539928</a><br>\n<code>genem=tee$logFC</code><br>\n<code>names(genem)=row.names(tee)</code><br>\n<code>pathview(gene.data = genem,pathway.id = '04514',species = 'hsa')</code><br>\n<code>pathway.id</code>是信号通路的id，如04514意味着Cell adhesion molecules通路，画出的是该样本在某通路上的基因表达量变化。<br>\n<code>gene.data</code>是样本的表达量，这个可以是foldchange,也可以是cpm等等。<br>\n<code>genem</code>的行名须是ENTRZID.<br>\n<code>species</code>是种类。<br>\n<img src=\"/2021/10/09/clusterProfiler/5.png\" alt></p>\n<h2 id=\"后续\"><a class=\"markdownIt-Anchor\" href=\"#后续\"></a> 后续</h2>\n<p>1.原理（长期）。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"clusterprofiler进行go-kegg以及相应的可视化\"><a class=\"markdownIt-Anchor\" href=\"#clusterprofiler进行go-kegg以及相应的可视化\"></a> clusterProfiler进行GO、KEGG以及相应的可视化</h1>\n<p>内容主要来源：<br>\n<a href=\"https://guangchuangyu.github.io/softwaredocumentation/\">https://guangchuangyu.github.io/softwaredocumentation/</a>（官方使用文档)</p>\n<h2 id=\"数据来源\"><a class=\"markdownIt-Anchor\" href=\"#数据来源\"></a> 数据来源</h2>\n<p><strong>差异基因列表：</strong><code>NCI-H460</code>癌症细胞同正常组织之间的差异基因。<br>\n承接自这篇笔记中:<a href=\"https://tanzhengtang.github.io/2021/09/27/EdgeR/\">EdgeR查找差异表达基因</a></p>\n<h2 id=\"过程\"><a class=\"markdownIt-Anchor\" href=\"#过程\"></a> 过程</h2>\n<h3 id=\"go分析\"><a class=\"markdownIt-Anchor\" href=\"#go分析\"></a> GO分析</h3>\n<p><strong>代码:</strong><br>\n<code>ego &lt;- enrichGO(gene = idt,OrgDb = org.Hs.eg.db,keyType = 'ENSEMBL',ont = &quot;ALL&quot;,pAdjustMethod = &quot;BH&quot;,pvalueCutoff = 0.01,qvalueCutoff  = 0.05,readable = T)</code><br>\n<strong>gene是得到的差异基因列表.<br>\nkeyType指定基因ID的类型,默认为ENTREZID.<br>\nOrgDb指定该物种对应的org包的名字.<br>\nont代表GO的3大类别，BP, CC, MF,而ALL是将该3类一起包含.<br>\npAdjustMethod指定多重假设检验矫正的方法.<br>\ncufoff指定对应的阈值.<br>\nreadable=TRUE将基因ID转换为gene symbol.</strong><br>\n<em>idt</em> 差异基因列表:<br>\n<img src=\"/2021/10/09/clusterProfiler/1.png\" alt><br>\n这样就可以直接出图了。<br>\n<code>dotplot(ego,showCategory = 10)</code><br>\n<img src=\"/2021/10/09/clusterProfiler/2.png\" alt><br>\n<code>barplot(ego,showCategory = 10)</code><br>\n<img src=\"/2021/10/09/clusterProfiler/3.png\" alt></p>\n<h3 id=\"kegg分析\"><a class=\"markdownIt-Anchor\" href=\"#kegg分析\"></a> KEGG分析</h3>\n<p>在代码方面同GO分析差不多:<br>\n<code>kk=enrichKEGG(te$entrzid,organism=&quot;hsa&quot;, pvalueCutoff=0.05,pAdjustMethod=&quot;BH&quot;,qvalueCutoff=0.1)</code><br>\n<code>kk=setReadable(kk,OrgDb = org.Hs.eg.db,keyType = 'ENTREZID')</code><br>\n经尝试，KEGG分析似乎不支持ENSEMBL的ID，所以运行上面之前先转换成ENTRZID:<br>\n<code>en=mapIds(x = org.Hs.eg.db,keys = ed$symbol,keytype = &quot;SYMBOL&quot;,column = &quot;ENTREZID&quot;)</code><br>\n<code>ed$entrzid=en</code><br>\n<code>te=na.omit(ed)</code><br>\n出图：<br>\n<code>barplot(kk,ddrop=T,showCategory =10,title=&quot;KEGG Enrichment Pathways&quot;)</code><br>\n<img src=\"/2021/10/09/clusterProfiler/4.png\" alt></p>\n<p><strong>额外的pathview图：</strong><br>\n内容来源:<br>\n<a href=\"https://cloud.tencent.com/developer/article/1539928\">https://cloud.tencent.com/developer/article/1539928</a><br>\n<code>genem=tee$logFC</code><br>\n<code>names(genem)=row.names(tee)</code><br>\n<code>pathview(gene.data = genem,pathway.id = '04514',species = 'hsa')</code><br>\n<code>pathway.id</code>是信号通路的id，如04514意味着Cell adhesion molecules通路，画出的是该样本在某通路上的基因表达量变化。<br>\n<code>gene.data</code>是样本的表达量，这个可以是foldchange,也可以是cpm等等。<br>\n<code>genem</code>的行名须是ENTRZID.<br>\n<code>species</code>是种类。<br>\n<img src=\"/2021/10/09/clusterProfiler/5.png\" alt></p>\n<h2 id=\"后续\"><a class=\"markdownIt-Anchor\" href=\"#后续\"></a> 后续</h2>\n<p>1.原理（长期）。</p>\n"},{"title":"推送博客配置及笔记至github","date":"2023-02-18T13:08:49.000Z","toc":true,"_content":"# 推送博客配置及笔记至github   \n内容来自知乎：[https://zhuanlan.zhihu.com/p/187435941](https://zhuanlan.zhihu.com/p/187435941)     \n此项笔记仅仅是为防丢。\n若没有这样的措施，换台电脑就非常麻烦，什么都要重新弄。  \n\n## 原理   \n1. `github.io`站点只是展示`master`上的静态文件，我们可以再在这个仓库里创建新的分支，然后将本地的源代码推送至该分支即可。  \n2. 运行`hexo d`时，生成的静态代码（在public文件夹中）会被自动push到远程仓库的maser分支。  \n\n## 操作   \n1. 解决.gitgnore文件中的忽略项，一般情况下包含以下内容:  \n`.DS_Store, Thumbs.db, db.json, *.log, node_modules/, public/, .deploy*/\n`  \n去除掉`db.json,\nThumbs.db, \nnode-modules/,`  \n这3项包含hexo相关插件的重要信息，因此无需被忽略。  \n2. 完成后执行`git add * ; git commit -m \"first commit\"`  \n3. 若没有关联远程仓库，则`git checkout -b source; git remote add github 远程仓库地址; git push -u github source`  \n4. 此时，我们最好去github上的远程仓库上，将远程仓库的主分支设置为source分支（默认为master分支）。（因为主分支不容易被删除。当我们意外删除主分支的时候，github会提醒我们这是主分支，这可以防止我们不小心删除source分支。并且，当我们在另一台电脑上从远程仓库clone时，本地仓库默认所在的分支是source分支。）  \n\n## 后记   \n一个仓库两个分支，默认情况下github pages服务展示的是master分支的静态代码，而笔记文件和配置的其他东西手动可推送至另一分支。  ","source":"_posts/pusblogct.md","raw":"---\ntitle: 推送博客配置及笔记至github\ndate: 2023-02-18 21:08:49\ncategories: \n- Blog\ntags: \n- Blog\n- Web\ntoc: true\n---\n# 推送博客配置及笔记至github   \n内容来自知乎：[https://zhuanlan.zhihu.com/p/187435941](https://zhuanlan.zhihu.com/p/187435941)     \n此项笔记仅仅是为防丢。\n若没有这样的措施，换台电脑就非常麻烦，什么都要重新弄。  \n\n## 原理   \n1. `github.io`站点只是展示`master`上的静态文件，我们可以再在这个仓库里创建新的分支，然后将本地的源代码推送至该分支即可。  \n2. 运行`hexo d`时，生成的静态代码（在public文件夹中）会被自动push到远程仓库的maser分支。  \n\n## 操作   \n1. 解决.gitgnore文件中的忽略项，一般情况下包含以下内容:  \n`.DS_Store, Thumbs.db, db.json, *.log, node_modules/, public/, .deploy*/\n`  \n去除掉`db.json,\nThumbs.db, \nnode-modules/,`  \n这3项包含hexo相关插件的重要信息，因此无需被忽略。  \n2. 完成后执行`git add * ; git commit -m \"first commit\"`  \n3. 若没有关联远程仓库，则`git checkout -b source; git remote add github 远程仓库地址; git push -u github source`  \n4. 此时，我们最好去github上的远程仓库上，将远程仓库的主分支设置为source分支（默认为master分支）。（因为主分支不容易被删除。当我们意外删除主分支的时候，github会提醒我们这是主分支，这可以防止我们不小心删除source分支。并且，当我们在另一台电脑上从远程仓库clone时，本地仓库默认所在的分支是source分支。）  \n\n## 后记   \n一个仓库两个分支，默认情况下github pages服务展示的是master分支的静态代码，而笔记文件和配置的其他东西手动可推送至另一分支。  ","slug":"pusblogct","published":1,"updated":"2023-02-18T13:09:57.467Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cleb7c83c000c1q96chigezyt","content":"<h1 id=\"推送博客配置及笔记至github\"><a class=\"markdownIt-Anchor\" href=\"#推送博客配置及笔记至github\"></a> 推送博客配置及笔记至github</h1>\n<p>内容来自知乎：<a href=\"https://zhuanlan.zhihu.com/p/187435941\">https://zhuanlan.zhihu.com/p/187435941</a><br>\n此项笔记仅仅是为防丢。<br>\n若没有这样的措施，换台电脑就非常麻烦，什么都要重新弄。</p>\n<h2 id=\"原理\"><a class=\"markdownIt-Anchor\" href=\"#原理\"></a> 原理</h2>\n<ol>\n<li><code>github.io</code>站点只是展示<code>master</code>上的静态文件，我们可以再在这个仓库里创建新的分支，然后将本地的源代码推送至该分支即可。</li>\n<li>运行<code>hexo d</code>时，生成的静态代码（在public文件夹中）会被自动push到远程仓库的maser分支。</li>\n</ol>\n<h2 id=\"操作\"><a class=\"markdownIt-Anchor\" href=\"#操作\"></a> 操作</h2>\n<ol>\n<li>解决.gitgnore文件中的忽略项，一般情况下包含以下内容:<br>\n<code>.DS_Store, Thumbs.db, db.json, *.log, node_modules/, public/, .deploy*/ </code><br>\n去除掉<code>db.json, Thumbs.db,  node-modules/,</code><br>\n这3项包含hexo相关插件的重要信息，因此无需被忽略。</li>\n<li>完成后执行<code>git add * ; git commit -m &quot;first commit&quot;</code></li>\n<li>若没有关联远程仓库，则<code>git checkout -b source; git remote add github 远程仓库地址; git push -u github source</code></li>\n<li>此时，我们最好去github上的远程仓库上，将远程仓库的主分支设置为source分支（默认为master分支）。（因为主分支不容易被删除。当我们意外删除主分支的时候，github会提醒我们这是主分支，这可以防止我们不小心删除source分支。并且，当我们在另一台电脑上从远程仓库clone时，本地仓库默认所在的分支是source分支。）</li>\n</ol>\n<h2 id=\"后记\"><a class=\"markdownIt-Anchor\" href=\"#后记\"></a> 后记</h2>\n<p>一个仓库两个分支，默认情况下github pages服务展示的是master分支的静态代码，而笔记文件和配置的其他东西手动可推送至另一分支。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"推送博客配置及笔记至github\"><a class=\"markdownIt-Anchor\" href=\"#推送博客配置及笔记至github\"></a> 推送博客配置及笔记至github</h1>\n<p>内容来自知乎：<a href=\"https://zhuanlan.zhihu.com/p/187435941\">https://zhuanlan.zhihu.com/p/187435941</a><br>\n此项笔记仅仅是为防丢。<br>\n若没有这样的措施，换台电脑就非常麻烦，什么都要重新弄。</p>\n<h2 id=\"原理\"><a class=\"markdownIt-Anchor\" href=\"#原理\"></a> 原理</h2>\n<ol>\n<li><code>github.io</code>站点只是展示<code>master</code>上的静态文件，我们可以再在这个仓库里创建新的分支，然后将本地的源代码推送至该分支即可。</li>\n<li>运行<code>hexo d</code>时，生成的静态代码（在public文件夹中）会被自动push到远程仓库的maser分支。</li>\n</ol>\n<h2 id=\"操作\"><a class=\"markdownIt-Anchor\" href=\"#操作\"></a> 操作</h2>\n<ol>\n<li>解决.gitgnore文件中的忽略项，一般情况下包含以下内容:<br>\n<code>.DS_Store, Thumbs.db, db.json, *.log, node_modules/, public/, .deploy*/ </code><br>\n去除掉<code>db.json, Thumbs.db,  node-modules/,</code><br>\n这3项包含hexo相关插件的重要信息，因此无需被忽略。</li>\n<li>完成后执行<code>git add * ; git commit -m &quot;first commit&quot;</code></li>\n<li>若没有关联远程仓库，则<code>git checkout -b source; git remote add github 远程仓库地址; git push -u github source</code></li>\n<li>此时，我们最好去github上的远程仓库上，将远程仓库的主分支设置为source分支（默认为master分支）。（因为主分支不容易被删除。当我们意外删除主分支的时候，github会提醒我们这是主分支，这可以防止我们不小心删除source分支。并且，当我们在另一台电脑上从远程仓库clone时，本地仓库默认所在的分支是source分支。）</li>\n</ol>\n<h2 id=\"后记\"><a class=\"markdownIt-Anchor\" href=\"#后记\"></a> 后记</h2>\n<p>一个仓库两个分支，默认情况下github pages服务展示的是master分支的静态代码，而笔记文件和配置的其他东西手动可推送至另一分支。</p>\n"},{"title":"统计学习方法三要素","date":"2022-04-04T16:00:00.000Z","mathjax":true,"toc":true,"_content":"# 统计学习方法三要素  \n课程内容：  \n[https://www.bilibili.com/video/BV1No4y1o7ac?p=4](https://www.bilibili.com/video/BV1No4y1o7ac?p=4)  \n\n## 纲要  \n\n### 三要素的定义  \n\n> 统计学习方法的三要素为模型、策略、算法。  \n1. 模型是所有可能的条件概率分布或决策函数，用$\\mathcal{F}$表示。而所有的模型的集合称之为假设空间。  \n> 对于决策函数，实际上并不是很清楚。课程中，讲课者也只是说了它为非条件概率分布模型。\n> 百度百科上，决策函数用于数据分类。例子：在二分类情况下，有决策函数$y=f(x)$，当$y > 0$时，所取$x$实例集合便是一类，$y<0$时的其他实例便是另一类。当然这些可以延伸到多分类问题。  \n> 如此看来的话，个人的理解便是：条件概率分布用于预测，而决策函数则是用于分类。  \n\n1. 策略是用于选择最优模型的。  \n一般由损失函数来度量模型一次预测的好坏，记作$L(Y,f(X))$  \n而度量所有情况下（平均意义下）的模型预测的好坏，则是$R_e = E_p[L(Y,f(X)]$  \n而$L$函数是由$Y$和$f(x)$联合决定的，则可通过$E(x)=\\sum_{i = 1}^n P(x_i)x_i$  \n得到一般情况下的期望风险函数$R_e = \\int_{X Y} L(y,f(x))P(x,y)dxdy$   \n而往往$P(x,y)$我们是无法得知的，所以通常用经验风险来表示模型的平均损失：$R_{emp}(f) = \\cfrac{1}{N} \\sum_{i=1}^N L(y_i,f(x_i))$  \n\n> 损失函数顾名思义，便是预测值或者打分同实际值之间的差别。风险函数相当于把该损失函数应用于所有的实例来看这个模型好不好。  \n\n\n## 待定内容  \n### 待定内容 \n\n\n\n\n\n\n\n\n\n\n","source":"_posts/riskfunction.md","raw":"---\ntitle: 统计学习方法三要素\ndate: 2022-4-5\nmathjax: true\ncategories: \n- Statistical Learning Methods\ntags: \n- Deep Learning\n- Math\ntoc: true\n---\n# 统计学习方法三要素  \n课程内容：  \n[https://www.bilibili.com/video/BV1No4y1o7ac?p=4](https://www.bilibili.com/video/BV1No4y1o7ac?p=4)  \n\n## 纲要  \n\n### 三要素的定义  \n\n> 统计学习方法的三要素为模型、策略、算法。  \n1. 模型是所有可能的条件概率分布或决策函数，用$\\mathcal{F}$表示。而所有的模型的集合称之为假设空间。  \n> 对于决策函数，实际上并不是很清楚。课程中，讲课者也只是说了它为非条件概率分布模型。\n> 百度百科上，决策函数用于数据分类。例子：在二分类情况下，有决策函数$y=f(x)$，当$y > 0$时，所取$x$实例集合便是一类，$y<0$时的其他实例便是另一类。当然这些可以延伸到多分类问题。  \n> 如此看来的话，个人的理解便是：条件概率分布用于预测，而决策函数则是用于分类。  \n\n1. 策略是用于选择最优模型的。  \n一般由损失函数来度量模型一次预测的好坏，记作$L(Y,f(X))$  \n而度量所有情况下（平均意义下）的模型预测的好坏，则是$R_e = E_p[L(Y,f(X)]$  \n而$L$函数是由$Y$和$f(x)$联合决定的，则可通过$E(x)=\\sum_{i = 1}^n P(x_i)x_i$  \n得到一般情况下的期望风险函数$R_e = \\int_{X Y} L(y,f(x))P(x,y)dxdy$   \n而往往$P(x,y)$我们是无法得知的，所以通常用经验风险来表示模型的平均损失：$R_{emp}(f) = \\cfrac{1}{N} \\sum_{i=1}^N L(y_i,f(x_i))$  \n\n> 损失函数顾名思义，便是预测值或者打分同实际值之间的差别。风险函数相当于把该损失函数应用于所有的实例来看这个模型好不好。  \n\n\n## 待定内容  \n### 待定内容 \n\n\n\n\n\n\n\n\n\n\n","slug":"riskfunction","published":1,"updated":"2023-02-18T15:29:14.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cleb7c83f000g1q967rz9al2x","content":"<h1 id=\"统计学习方法三要素\"><a class=\"markdownIt-Anchor\" href=\"#统计学习方法三要素\"></a> 统计学习方法三要素</h1>\n<p>课程内容：<br>\n<a href=\"https://www.bilibili.com/video/BV1No4y1o7ac?p=4\">https://www.bilibili.com/video/BV1No4y1o7ac?p=4</a></p>\n<h2 id=\"纲要\"><a class=\"markdownIt-Anchor\" href=\"#纲要\"></a> 纲要</h2>\n<h3 id=\"三要素的定义\"><a class=\"markdownIt-Anchor\" href=\"#三要素的定义\"></a> 三要素的定义</h3>\n<blockquote>\n<p>统计学习方法的三要素为模型、策略、算法。</p>\n</blockquote>\n<ol>\n<li>模型是所有可能的条件概率分布或决策函数，用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">F</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{F}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span></span></span></span></span>表示。而所有的模型的集合称之为假设空间。</li>\n</ol>\n<blockquote>\n<p>对于决策函数，实际上并不是很清楚。课程中，讲课者也只是说了它为非条件概率分布模型。<br>\n百度百科上，决策函数用于数据分类。例子：在二分类情况下，有决策函数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">y=f(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>，当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">y &gt; 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>时，所取<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>实例集合便是一类，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">y&lt;0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>时的其他实例便是另一类。当然这些可以延伸到多分类问题。<br>\n如此看来的话，个人的理解便是：条件概率分布用于预测，而决策函数则是用于分类。</p>\n</blockquote>\n<ol>\n<li>策略是用于选择最优模型的。<br>\n一般由损失函数来度量模型一次预测的好坏，记作<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo stretchy=\"false\">(</mo><mi>Y</mi><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">L(Y,f(X))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span><br>\n而度量所有情况下（平均意义下）的模型预测的好坏，则是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>e</mi></msub><mo>=</mo><msub><mi>E</mi><mi>p</mi></msub><mo stretchy=\"false\">[</mo><mi>L</mi><mo stretchy=\"false\">(</mo><mi>Y</mi><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R_e = E_p[L(Y,f(X)]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mclose\">]</span></span></span></span><br>\n而<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>函数是由<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>联合决定的，则可通过<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>P</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">E(x)=\\sum_{i = 1}^n P(x_i)x_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.104002em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.804292em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span><br>\n得到一般情况下的期望风险函数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>e</mi></msub><mo>=</mo><msub><mo>∫</mo><mrow><mi>X</mi><mi>Y</mi></mrow></msub><mi>L</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mi>d</mi><mi>x</mi><mi>d</mi><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">R_e = \\int_{X Y} L(y,f(x))P(x,y)dxdy</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1608200000000002em;vertical-align:-0.35582em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;\">∫</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.12251099999999993em;\"><span style=\"top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">Y</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.35582em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span><br>\n而往往<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(x,y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span>我们是无法得知的，所以通常用经验风险来表示模型的平均损失：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mrow><mi>e</mi><mi>m</mi><mi>p</mi></mrow></msub><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mstyle displaystyle=\"true\" scriptlevel=\"0\"><mfrac><mn>1</mn><mi>N</mi></mfrac></mstyle><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mi>L</mi><mo stretchy=\"false\">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R_{emp}(f) = \\cfrac{1}{N} \\sum_{i=1}^N L(y_i,f(x_i))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">m</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.276em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5899999999999999em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.74em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.981231em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span></li>\n</ol>\n<blockquote>\n<p>损失函数顾名思义，便是预测值或者打分同实际值之间的差别。风险函数相当于把该损失函数应用于所有的实例来看这个模型好不好。</p>\n</blockquote>\n<h2 id=\"待定内容\"><a class=\"markdownIt-Anchor\" href=\"#待定内容\"></a> 待定内容</h2>\n<h3 id=\"待定内容-2\"><a class=\"markdownIt-Anchor\" href=\"#待定内容-2\"></a> 待定内容</h3>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"统计学习方法三要素\"><a class=\"markdownIt-Anchor\" href=\"#统计学习方法三要素\"></a> 统计学习方法三要素</h1>\n<p>课程内容：<br>\n<a href=\"https://www.bilibili.com/video/BV1No4y1o7ac?p=4\">https://www.bilibili.com/video/BV1No4y1o7ac?p=4</a></p>\n<h2 id=\"纲要\"><a class=\"markdownIt-Anchor\" href=\"#纲要\"></a> 纲要</h2>\n<h3 id=\"三要素的定义\"><a class=\"markdownIt-Anchor\" href=\"#三要素的定义\"></a> 三要素的定义</h3>\n<blockquote>\n<p>统计学习方法的三要素为模型、策略、算法。</p>\n</blockquote>\n<ol>\n<li>模型是所有可能的条件概率分布或决策函数，用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">F</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{F}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span></span></span></span></span>表示。而所有的模型的集合称之为假设空间。</li>\n</ol>\n<blockquote>\n<p>对于决策函数，实际上并不是很清楚。课程中，讲课者也只是说了它为非条件概率分布模型。<br>\n百度百科上，决策函数用于数据分类。例子：在二分类情况下，有决策函数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">y=f(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>，当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">y &gt; 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>时，所取<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>实例集合便是一类，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">y&lt;0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>时的其他实例便是另一类。当然这些可以延伸到多分类问题。<br>\n如此看来的话，个人的理解便是：条件概率分布用于预测，而决策函数则是用于分类。</p>\n</blockquote>\n<ol>\n<li>策略是用于选择最优模型的。<br>\n一般由损失函数来度量模型一次预测的好坏，记作<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo stretchy=\"false\">(</mo><mi>Y</mi><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">L(Y,f(X))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span><br>\n而度量所有情况下（平均意义下）的模型预测的好坏，则是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>e</mi></msub><mo>=</mo><msub><mi>E</mi><mi>p</mi></msub><mo stretchy=\"false\">[</mo><mi>L</mi><mo stretchy=\"false\">(</mo><mi>Y</mi><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R_e = E_p[L(Y,f(X)]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mclose\">]</span></span></span></span><br>\n而<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>函数是由<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>联合决定的，则可通过<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>P</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">E(x)=\\sum_{i = 1}^n P(x_i)x_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.104002em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.804292em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span><br>\n得到一般情况下的期望风险函数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>e</mi></msub><mo>=</mo><msub><mo>∫</mo><mrow><mi>X</mi><mi>Y</mi></mrow></msub><mi>L</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mi>d</mi><mi>x</mi><mi>d</mi><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">R_e = \\int_{X Y} L(y,f(x))P(x,y)dxdy</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1608200000000002em;vertical-align:-0.35582em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;\">∫</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.12251099999999993em;\"><span style=\"top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">Y</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.35582em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span><br>\n而往往<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(x,y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span>我们是无法得知的，所以通常用经验风险来表示模型的平均损失：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mrow><mi>e</mi><mi>m</mi><mi>p</mi></mrow></msub><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mstyle displaystyle=\"true\" scriptlevel=\"0\"><mfrac><mn>1</mn><mi>N</mi></mfrac></mstyle><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mi>L</mi><mo stretchy=\"false\">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R_{emp}(f) = \\cfrac{1}{N} \\sum_{i=1}^N L(y_i,f(x_i))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">m</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.276em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5899999999999999em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.74em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.981231em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span></li>\n</ol>\n<blockquote>\n<p>损失函数顾名思义，便是预测值或者打分同实际值之间的差别。风险函数相当于把该损失函数应用于所有的实例来看这个模型好不好。</p>\n</blockquote>\n<h2 id=\"待定内容\"><a class=\"markdownIt-Anchor\" href=\"#待定内容\"></a> 待定内容</h2>\n<h3 id=\"待定内容-2\"><a class=\"markdownIt-Anchor\" href=\"#待定内容-2\"></a> 待定内容</h3>\n"},{"title":"排序算法","date":"2022-04-24T16:00:00.000Z","mathjax":true,"toc":true,"_content":"  \n\n# 排序  \n均为笔记，内容来自:  \nhttps://oi-wiki.org/basic/sort-intro/  \n\n## 归并排序  \nhttps://blog.csdn.net/k_koris/article/details/80508543  \n归并排序是一种稳定的排序算法。  \n归并排序的最优时间复杂度、平均时间复杂度和最坏时间复杂度均为$O(nLogn)$。  \n归并排序的空间复杂度为$O(n)$。  \n\n* 分而治之的思想    \n1. 分解原问题为结构相同的子问题。  \n2. 分解到某个容易求解的边界之后，进行递归求解。  \n3. 将子问题的解合并成原问题的解。  \n\n* 递归  \n递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。  \n\n如：  \n```  \nint k(int a[],int i){\n    if(i <= 0){ return 0; }\n    i = i - 1;\n    return k(a,i) + 1;\n}\n``` \n**重点:明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节。**  \n\n### 步骤  \n考虑如下简单列表:  \n[5,4,10,3]  \n那么按照分而治之的思想，我们可将其划分成两个小的列表，[5,4]以及[10,3]，对他们各自排好序后再次进行归并。  \n排好序后的[4,5]以及[3,10]，归并的时候是两个有序的列表，这儿我们可以采用有序列表的合并算法进行合并。实际上，[4,5]中的[5]以及[4]也是按照有序列表进行合并的。  \n如果按照上述的思维，我们可将一个很大的列表进行循环递增分割至最小的列表，然后按照有序列表进行合并。  \n用别人精炼的语言，即:  \n1. 将数列划分为两部分；  \n2. 递归地分别对两个子序列进行归并排序；  \n3. 合并两个子序列。  \n\n将重点放在第3步上，合并两个有序的子序列。 \n\n```\n//a = [4,5]\n//b = [3,10]\nint* merge_sort(int a[],int b[]){\n    int a_size = sizeof(a)/sizeof(int);\n    int b_size = sizeof(b)/sizeof(int);\n    int tmp_size = a_size + b_size;\n    int tmp[tmp_size];\n    int s = 0;\n    int a_s = 0;\n    int b_s = 0;\n    int a_e = a_size - 1;\n    int b_e = b_size - 1;\n    //从头开始将每个列表进行比较。\n    //类似插入排序，两个列表中小的元素插入新的数组前面。由于是都是有序的序列，\n    //插入后只需将其中一个的指针往后移动，然后再进行比较。\n    while(a_s <= a_e && b_s <= b_e){\n        if(a[a_s] > b[b_s]){\n            tmp[s++] = a[a_s++];\n        }\n        else{\n            tmp[s++] = b[b_s++];\n        }\n    }\n    while(a_s <= a_e){\n        tmp[s++] = a[a_s++];\n    }\n    while(b_s <= b_e){\n        tmp[s++] = b[b_s++];\n    }\n    return tmp;\n}\n```\n\n上述的所花费的时间，即b_size + a_size，而这两个是由原先的列表所分割而成，即原列表的元素数量大小。  \n再来对1、2两步进行实现。  \n\n```\nvoid merge(int a[],int t[],int start,int end){\n    //终止条件即分割后的列表中最少存在1个元素。\n    if(start - end <= 1){return;}\n    int mid = start + ((start - end) >>  1);\n    //递归\n    merge(a,t,start,mid);\n    merge(a,t,mid,end);\n    //合并序列，所采用的思想同merge_sort中是一样的，但需进行一定改写，\n    //因为此处是自身的分割序列，为了减小开销，我们并未真正的开辟了两个数组进行比较。\n    int s = start;\n    int s1 = start;\n    int ed1 = mid;\n    int s2 = mid + 1;\n    int ed2 = end;\n    while(s1 <= ed1 && s2 <= ed2){\n        if(a[s1] > a[s2]){\n            t[s++] = a[s2++];\n        }\n        else{\n            t[s++] = a[s1++];\n        }\n    }\n    while(s1 <= ed1){\n        t[s++] = a[s1++];\n    }\n    while(s2 <= ed2){\n        t[s++] = a[s2++];\n    }\n}\n```  \n\n我们知道从各个子部分中间分割的话，所需的时间为$LogN$，而随着每一次递归，我们都进行了一次合并，乘以合并所需的时间即$NlogN$。  \n\n## 快速排序  \n内容待定","source":"_posts/sort.md","raw":"---\ntitle: 排序算法\ndate: 2022-4-25\nmathjax: true\ntoc: true\ncategories: \n- Algorithm\ntags: \n- Algorithm\n---  \n\n# 排序  \n均为笔记，内容来自:  \nhttps://oi-wiki.org/basic/sort-intro/  \n\n## 归并排序  \nhttps://blog.csdn.net/k_koris/article/details/80508543  \n归并排序是一种稳定的排序算法。  \n归并排序的最优时间复杂度、平均时间复杂度和最坏时间复杂度均为$O(nLogn)$。  \n归并排序的空间复杂度为$O(n)$。  \n\n* 分而治之的思想    \n1. 分解原问题为结构相同的子问题。  \n2. 分解到某个容易求解的边界之后，进行递归求解。  \n3. 将子问题的解合并成原问题的解。  \n\n* 递归  \n递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。  \n\n如：  \n```  \nint k(int a[],int i){\n    if(i <= 0){ return 0; }\n    i = i - 1;\n    return k(a,i) + 1;\n}\n``` \n**重点:明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节。**  \n\n### 步骤  \n考虑如下简单列表:  \n[5,4,10,3]  \n那么按照分而治之的思想，我们可将其划分成两个小的列表，[5,4]以及[10,3]，对他们各自排好序后再次进行归并。  \n排好序后的[4,5]以及[3,10]，归并的时候是两个有序的列表，这儿我们可以采用有序列表的合并算法进行合并。实际上，[4,5]中的[5]以及[4]也是按照有序列表进行合并的。  \n如果按照上述的思维，我们可将一个很大的列表进行循环递增分割至最小的列表，然后按照有序列表进行合并。  \n用别人精炼的语言，即:  \n1. 将数列划分为两部分；  \n2. 递归地分别对两个子序列进行归并排序；  \n3. 合并两个子序列。  \n\n将重点放在第3步上，合并两个有序的子序列。 \n\n```\n//a = [4,5]\n//b = [3,10]\nint* merge_sort(int a[],int b[]){\n    int a_size = sizeof(a)/sizeof(int);\n    int b_size = sizeof(b)/sizeof(int);\n    int tmp_size = a_size + b_size;\n    int tmp[tmp_size];\n    int s = 0;\n    int a_s = 0;\n    int b_s = 0;\n    int a_e = a_size - 1;\n    int b_e = b_size - 1;\n    //从头开始将每个列表进行比较。\n    //类似插入排序，两个列表中小的元素插入新的数组前面。由于是都是有序的序列，\n    //插入后只需将其中一个的指针往后移动，然后再进行比较。\n    while(a_s <= a_e && b_s <= b_e){\n        if(a[a_s] > b[b_s]){\n            tmp[s++] = a[a_s++];\n        }\n        else{\n            tmp[s++] = b[b_s++];\n        }\n    }\n    while(a_s <= a_e){\n        tmp[s++] = a[a_s++];\n    }\n    while(b_s <= b_e){\n        tmp[s++] = b[b_s++];\n    }\n    return tmp;\n}\n```\n\n上述的所花费的时间，即b_size + a_size，而这两个是由原先的列表所分割而成，即原列表的元素数量大小。  \n再来对1、2两步进行实现。  \n\n```\nvoid merge(int a[],int t[],int start,int end){\n    //终止条件即分割后的列表中最少存在1个元素。\n    if(start - end <= 1){return;}\n    int mid = start + ((start - end) >>  1);\n    //递归\n    merge(a,t,start,mid);\n    merge(a,t,mid,end);\n    //合并序列，所采用的思想同merge_sort中是一样的，但需进行一定改写，\n    //因为此处是自身的分割序列，为了减小开销，我们并未真正的开辟了两个数组进行比较。\n    int s = start;\n    int s1 = start;\n    int ed1 = mid;\n    int s2 = mid + 1;\n    int ed2 = end;\n    while(s1 <= ed1 && s2 <= ed2){\n        if(a[s1] > a[s2]){\n            t[s++] = a[s2++];\n        }\n        else{\n            t[s++] = a[s1++];\n        }\n    }\n    while(s1 <= ed1){\n        t[s++] = a[s1++];\n    }\n    while(s2 <= ed2){\n        t[s++] = a[s2++];\n    }\n}\n```  \n\n我们知道从各个子部分中间分割的话，所需的时间为$LogN$，而随着每一次递归，我们都进行了一次合并，乘以合并所需的时间即$NlogN$。  \n\n## 快速排序  \n内容待定","slug":"sort","published":1,"updated":"2023-02-18T13:26:34.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cleb7c83g000i1q964xrwhne7","content":"<h1 id=\"排序\"><a class=\"markdownIt-Anchor\" href=\"#排序\"></a> 排序</h1>\n<p>均为笔记，内容来自:<br>\n<a href=\"https://oi-wiki.org/basic/sort-intro/\">https://oi-wiki.org/basic/sort-intro/</a></p>\n<h2 id=\"归并排序\"><a class=\"markdownIt-Anchor\" href=\"#归并排序\"></a> 归并排序</h2>\n<p><a href=\"https://blog.csdn.net/k_koris/article/details/80508543\">https://blog.csdn.net/k_koris/article/details/80508543</a><br>\n归并排序是一种稳定的排序算法。<br>\n归并排序的最优时间复杂度、平均时间复杂度和最坏时间复杂度均为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>L</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nLogn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。<br>\n归并排序的空间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<ul>\n<li>分而治之的思想</li>\n</ul>\n<ol>\n<li>分解原问题为结构相同的子问题。</li>\n<li>分解到某个容易求解的边界之后，进行递归求解。</li>\n<li>将子问题的解合并成原问题的解。</li>\n</ol>\n<ul>\n<li>递归<br>\n递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。</li>\n</ul>\n<p>如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int k(int a[],int i)&#123;</span><br><span class=\"line\">    if(i &lt;= 0)&#123; return 0; &#125;</span><br><span class=\"line\">    i = i - 1;</span><br><span class=\"line\">    return k(a,i) + 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>重点:明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节。</strong></p>\n<h3 id=\"步骤\"><a class=\"markdownIt-Anchor\" href=\"#步骤\"></a> 步骤</h3>\n<p>考虑如下简单列表:<br>\n[5,4,10,3]<br>\n那么按照分而治之的思想，我们可将其划分成两个小的列表，[5,4]以及[10,3]，对他们各自排好序后再次进行归并。<br>\n排好序后的[4,5]以及[3,10]，归并的时候是两个有序的列表，这儿我们可以采用有序列表的合并算法进行合并。实际上，[4,5]中的[5]以及[4]也是按照有序列表进行合并的。<br>\n如果按照上述的思维，我们可将一个很大的列表进行循环递增分割至最小的列表，然后按照有序列表进行合并。<br>\n用别人精炼的语言，即:</p>\n<ol>\n<li>将数列划分为两部分；</li>\n<li>递归地分别对两个子序列进行归并排序；</li>\n<li>合并两个子序列。</li>\n</ol>\n<p>将重点放在第3步上，合并两个有序的子序列。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//a = [4,5]</span><br><span class=\"line\">//b = [3,10]</span><br><span class=\"line\">int* merge_sort(int a[],int b[])&#123;</span><br><span class=\"line\">    int a_size = sizeof(a)/sizeof(int);</span><br><span class=\"line\">    int b_size = sizeof(b)/sizeof(int);</span><br><span class=\"line\">    int tmp_size = a_size + b_size;</span><br><span class=\"line\">    int tmp[tmp_size];</span><br><span class=\"line\">    int s = 0;</span><br><span class=\"line\">    int a_s = 0;</span><br><span class=\"line\">    int b_s = 0;</span><br><span class=\"line\">    int a_e = a_size - 1;</span><br><span class=\"line\">    int b_e = b_size - 1;</span><br><span class=\"line\">    //从头开始将每个列表进行比较。</span><br><span class=\"line\">    //类似插入排序，两个列表中小的元素插入新的数组前面。由于是都是有序的序列，</span><br><span class=\"line\">    //插入后只需将其中一个的指针往后移动，然后再进行比较。</span><br><span class=\"line\">    while(a_s &lt;= a_e &amp;&amp; b_s &lt;= b_e)&#123;</span><br><span class=\"line\">        if(a[a_s] &gt; b[b_s])&#123;</span><br><span class=\"line\">            tmp[s++] = a[a_s++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else&#123;</span><br><span class=\"line\">            tmp[s++] = b[b_s++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while(a_s &lt;= a_e)&#123;</span><br><span class=\"line\">        tmp[s++] = a[a_s++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while(b_s &lt;= b_e)&#123;</span><br><span class=\"line\">        tmp[s++] = b[b_s++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述的所花费的时间，即b_size + a_size，而这两个是由原先的列表所分割而成，即原列表的元素数量大小。<br>\n再来对1、2两步进行实现。</p>\n<pre class=\"highlight\"><code class>void merge(int a[],int t[],int start,int end)&#123;\n    //终止条件即分割后的列表中最少存在1个元素。\n    if(start - end &lt;= 1)&#123;return;&#125;\n    int mid = start + ((start - end) &gt;&gt;  1);\n    //递归\n    merge(a,t,start,mid);\n    merge(a,t,mid,end);\n    //合并序列，所采用的思想同merge_sort中是一样的，但需进行一定改写，\n    //因为此处是自身的分割序列，为了减小开销，我们并未真正的开辟了两个数组进行比较。\n    int s = start;\n    int s1 = start;\n    int ed1 = mid;\n    int s2 = mid + 1;\n    int ed2 = end;\n    while(s1 &lt;= ed1 &amp;&amp; s2 &lt;= ed2)&#123;\n        if(a[s1] &gt; a[s2])&#123;\n            t[s++] = a[s2++];\n        &#125;\n        else&#123;\n            t[s++] = a[s1++];\n        &#125;\n    &#125;\n    while(s1 &lt;= ed1)&#123;\n        t[s++] = a[s1++];\n    &#125;\n    while(s2 &lt;= ed2)&#123;\n        t[s++] = a[s2++];\n    &#125;\n&#125;\n</code></pre>\n<p>我们知道从各个子部分中间分割的话，所需的时间为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">LogN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>，而随着每一次递归，我们都进行了一次合并，乘以合并所需的时间即<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">NlogN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>。</p>\n<h2 id=\"快速排序\"><a class=\"markdownIt-Anchor\" href=\"#快速排序\"></a> 快速排序</h2>\n<p>内容待定</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"排序\"><a class=\"markdownIt-Anchor\" href=\"#排序\"></a> 排序</h1>\n<p>均为笔记，内容来自:<br>\n<a href=\"https://oi-wiki.org/basic/sort-intro/\">https://oi-wiki.org/basic/sort-intro/</a></p>\n<h2 id=\"归并排序\"><a class=\"markdownIt-Anchor\" href=\"#归并排序\"></a> 归并排序</h2>\n<p><a href=\"https://blog.csdn.net/k_koris/article/details/80508543\">https://blog.csdn.net/k_koris/article/details/80508543</a><br>\n归并排序是一种稳定的排序算法。<br>\n归并排序的最优时间复杂度、平均时间复杂度和最坏时间复杂度均为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>L</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nLogn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。<br>\n归并排序的空间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<ul>\n<li>分而治之的思想</li>\n</ul>\n<ol>\n<li>分解原问题为结构相同的子问题。</li>\n<li>分解到某个容易求解的边界之后，进行递归求解。</li>\n<li>将子问题的解合并成原问题的解。</li>\n</ol>\n<ul>\n<li>递归<br>\n递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。</li>\n</ul>\n<p>如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int k(int a[],int i)&#123;</span><br><span class=\"line\">    if(i &lt;= 0)&#123; return 0; &#125;</span><br><span class=\"line\">    i = i - 1;</span><br><span class=\"line\">    return k(a,i) + 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>重点:明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节。</strong></p>\n<h3 id=\"步骤\"><a class=\"markdownIt-Anchor\" href=\"#步骤\"></a> 步骤</h3>\n<p>考虑如下简单列表:<br>\n[5,4,10,3]<br>\n那么按照分而治之的思想，我们可将其划分成两个小的列表，[5,4]以及[10,3]，对他们各自排好序后再次进行归并。<br>\n排好序后的[4,5]以及[3,10]，归并的时候是两个有序的列表，这儿我们可以采用有序列表的合并算法进行合并。实际上，[4,5]中的[5]以及[4]也是按照有序列表进行合并的。<br>\n如果按照上述的思维，我们可将一个很大的列表进行循环递增分割至最小的列表，然后按照有序列表进行合并。<br>\n用别人精炼的语言，即:</p>\n<ol>\n<li>将数列划分为两部分；</li>\n<li>递归地分别对两个子序列进行归并排序；</li>\n<li>合并两个子序列。</li>\n</ol>\n<p>将重点放在第3步上，合并两个有序的子序列。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//a = [4,5]</span><br><span class=\"line\">//b = [3,10]</span><br><span class=\"line\">int* merge_sort(int a[],int b[])&#123;</span><br><span class=\"line\">    int a_size = sizeof(a)/sizeof(int);</span><br><span class=\"line\">    int b_size = sizeof(b)/sizeof(int);</span><br><span class=\"line\">    int tmp_size = a_size + b_size;</span><br><span class=\"line\">    int tmp[tmp_size];</span><br><span class=\"line\">    int s = 0;</span><br><span class=\"line\">    int a_s = 0;</span><br><span class=\"line\">    int b_s = 0;</span><br><span class=\"line\">    int a_e = a_size - 1;</span><br><span class=\"line\">    int b_e = b_size - 1;</span><br><span class=\"line\">    //从头开始将每个列表进行比较。</span><br><span class=\"line\">    //类似插入排序，两个列表中小的元素插入新的数组前面。由于是都是有序的序列，</span><br><span class=\"line\">    //插入后只需将其中一个的指针往后移动，然后再进行比较。</span><br><span class=\"line\">    while(a_s &lt;= a_e &amp;&amp; b_s &lt;= b_e)&#123;</span><br><span class=\"line\">        if(a[a_s] &gt; b[b_s])&#123;</span><br><span class=\"line\">            tmp[s++] = a[a_s++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else&#123;</span><br><span class=\"line\">            tmp[s++] = b[b_s++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while(a_s &lt;= a_e)&#123;</span><br><span class=\"line\">        tmp[s++] = a[a_s++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while(b_s &lt;= b_e)&#123;</span><br><span class=\"line\">        tmp[s++] = b[b_s++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述的所花费的时间，即b_size + a_size，而这两个是由原先的列表所分割而成，即原列表的元素数量大小。<br>\n再来对1、2两步进行实现。</p>\n<pre class=\"highlight\"><code class>void merge(int a[],int t[],int start,int end)&#123;\n    //终止条件即分割后的列表中最少存在1个元素。\n    if(start - end &lt;= 1)&#123;return;&#125;\n    int mid = start + ((start - end) &gt;&gt;  1);\n    //递归\n    merge(a,t,start,mid);\n    merge(a,t,mid,end);\n    //合并序列，所采用的思想同merge_sort中是一样的，但需进行一定改写，\n    //因为此处是自身的分割序列，为了减小开销，我们并未真正的开辟了两个数组进行比较。\n    int s = start;\n    int s1 = start;\n    int ed1 = mid;\n    int s2 = mid + 1;\n    int ed2 = end;\n    while(s1 &lt;= ed1 &amp;&amp; s2 &lt;= ed2)&#123;\n        if(a[s1] &gt; a[s2])&#123;\n            t[s++] = a[s2++];\n        &#125;\n        else&#123;\n            t[s++] = a[s1++];\n        &#125;\n    &#125;\n    while(s1 &lt;= ed1)&#123;\n        t[s++] = a[s1++];\n    &#125;\n    while(s2 &lt;= ed2)&#123;\n        t[s++] = a[s2++];\n    &#125;\n&#125;\n</code></pre>\n<p>我们知道从各个子部分中间分割的话，所需的时间为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">LogN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>，而随着每一次递归，我们都进行了一次合并，乘以合并所需的时间即<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">NlogN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>。</p>\n<h2 id=\"快速排序\"><a class=\"markdownIt-Anchor\" href=\"#快速排序\"></a> 快速排序</h2>\n<p>内容待定</p>\n"},{"title":"基数排序","date":"2021-10-08T16:00:00.000Z","_content":"# 基数排序  \n内容主要来源：  \n[https://oi-wiki.org/basic/radix-sort/](https://oi-wiki.org/basic/radix-sort/)（OI Wiki）\n[https://www.runoob.com/w3cnote/radix-sort.html](https://www.runoob.com/w3cnote/radix-sort.html)（菜鸟教程）  \n## 简介  \n基数排序（英语：Radix sort）是一种非比较型的排序算法，最早用于解决卡片排序的问题。\n\n它的工作原理是将待排序的元素拆分为  个关键字（比较两个元素时，先比较第一关键字，如果相同再比较第二关键字……），然后先对第  关键字进行稳定排序，再对第  关键字进行稳定排序，再对第  关键字进行稳定排序……最后对第一关键字进行稳定排序，这样就完成了对整个待排序序列的稳定排序。  \n\n**基数排序 vs 计数排序 vs 桶排序**  \n基数排序有两种方法：\n这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异。  \n**基数排序：** 根据键值的每位数字来分配桶；  \n**计数排序：** 每个桶只存储单一键值；  \n**桶排序：** 每个桶存储一定范围的数值。  \n## 代码\n\n\n## 后续\n1.原理（长期）。\n\n\n\n\n\n\n\n\n\n","source":"_posts/Algorithm/radix-sort.md","raw":"---\ntitle: 基数排序\ndate: 2021-10-09\ncategories: \n- Algorithm\ntags: \n- Algorithm\n- Math\n---\n# 基数排序  \n内容主要来源：  \n[https://oi-wiki.org/basic/radix-sort/](https://oi-wiki.org/basic/radix-sort/)（OI Wiki）\n[https://www.runoob.com/w3cnote/radix-sort.html](https://www.runoob.com/w3cnote/radix-sort.html)（菜鸟教程）  \n## 简介  \n基数排序（英语：Radix sort）是一种非比较型的排序算法，最早用于解决卡片排序的问题。\n\n它的工作原理是将待排序的元素拆分为  个关键字（比较两个元素时，先比较第一关键字，如果相同再比较第二关键字……），然后先对第  关键字进行稳定排序，再对第  关键字进行稳定排序，再对第  关键字进行稳定排序……最后对第一关键字进行稳定排序，这样就完成了对整个待排序序列的稳定排序。  \n\n**基数排序 vs 计数排序 vs 桶排序**  \n基数排序有两种方法：\n这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异。  \n**基数排序：** 根据键值的每位数字来分配桶；  \n**计数排序：** 每个桶只存储单一键值；  \n**桶排序：** 每个桶存储一定范围的数值。  \n## 代码\n\n\n## 后续\n1.原理（长期）。\n\n\n\n\n\n\n\n\n\n","slug":"Algorithm/radix-sort","published":1,"updated":"2023-02-18T13:31:08.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cleb7c83i000m1q96gx92auh3","content":"<h1 id=\"基数排序\"><a class=\"markdownIt-Anchor\" href=\"#基数排序\"></a> 基数排序</h1>\n<p>内容主要来源：<br>\n<a href=\"https://oi-wiki.org/basic/radix-sort/\">https://oi-wiki.org/basic/radix-sort/</a>（OI Wiki）<br>\n<a href=\"https://www.runoob.com/w3cnote/radix-sort.html\">https://www.runoob.com/w3cnote/radix-sort.html</a>（菜鸟教程）</p>\n<h2 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h2>\n<p>基数排序（英语：Radix sort）是一种非比较型的排序算法，最早用于解决卡片排序的问题。</p>\n<p>它的工作原理是将待排序的元素拆分为  个关键字（比较两个元素时，先比较第一关键字，如果相同再比较第二关键字……），然后先对第  关键字进行稳定排序，再对第  关键字进行稳定排序，再对第  关键字进行稳定排序……最后对第一关键字进行稳定排序，这样就完成了对整个待排序序列的稳定排序。</p>\n<p><strong>基数排序 vs 计数排序 vs 桶排序</strong><br>\n基数排序有两种方法：<br>\n这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异。<br>\n<strong>基数排序：</strong> 根据键值的每位数字来分配桶；<br>\n<strong>计数排序：</strong> 每个桶只存储单一键值；<br>\n<strong>桶排序：</strong> 每个桶存储一定范围的数值。</p>\n<h2 id=\"代码\"><a class=\"markdownIt-Anchor\" href=\"#代码\"></a> 代码</h2>\n<h2 id=\"后续\"><a class=\"markdownIt-Anchor\" href=\"#后续\"></a> 后续</h2>\n<p>1.原理（长期）。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基数排序\"><a class=\"markdownIt-Anchor\" href=\"#基数排序\"></a> 基数排序</h1>\n<p>内容主要来源：<br>\n<a href=\"https://oi-wiki.org/basic/radix-sort/\">https://oi-wiki.org/basic/radix-sort/</a>（OI Wiki）<br>\n<a href=\"https://www.runoob.com/w3cnote/radix-sort.html\">https://www.runoob.com/w3cnote/radix-sort.html</a>（菜鸟教程）</p>\n<h2 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h2>\n<p>基数排序（英语：Radix sort）是一种非比较型的排序算法，最早用于解决卡片排序的问题。</p>\n<p>它的工作原理是将待排序的元素拆分为  个关键字（比较两个元素时，先比较第一关键字，如果相同再比较第二关键字……），然后先对第  关键字进行稳定排序，再对第  关键字进行稳定排序，再对第  关键字进行稳定排序……最后对第一关键字进行稳定排序，这样就完成了对整个待排序序列的稳定排序。</p>\n<p><strong>基数排序 vs 计数排序 vs 桶排序</strong><br>\n基数排序有两种方法：<br>\n这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异。<br>\n<strong>基数排序：</strong> 根据键值的每位数字来分配桶；<br>\n<strong>计数排序：</strong> 每个桶只存储单一键值；<br>\n<strong>桶排序：</strong> 每个桶存储一定范围的数值。</p>\n<h2 id=\"代码\"><a class=\"markdownIt-Anchor\" href=\"#代码\"></a> 代码</h2>\n<h2 id=\"后续\"><a class=\"markdownIt-Anchor\" href=\"#后续\"></a> 后续</h2>\n<p>1.原理（长期）。</p>\n"},{"title":"插入排序","date":"2021-10-08T16:00:00.000Z","_content":"# 插入排序  \n内容主要来源：  \n[https://oi-wiki.org/basic/radix-sort/](https://oi-wiki.org/basic/insertion-sort/)（OI Wiki）\n[https://www.runoob.com/w3cnote/radix-sort.html](https://www.runoob.com/w3cnote/insertion-sort.html)（菜鸟教程）  \n## 简介  \n插入排序（英语：Insertion sort）是一种简单直观的排序算法。它的工作原理为将待排列元素划分为“已排序”和“未排序”两部分，每次从“未排序的”元素中选择一个插入到“已排序的”元素中的正确位置。\n一个与插入排序相同的操作是打扑克牌时，从牌桌上抓一张牌，按牌面大小插到手牌后，再抓下一张牌。\n \n## 时空复杂度  \n插入排序的最优时间复杂度为$O(n)$，在数列几乎有序时效率很高。  \n插入排序的最坏时间复杂度和平均时间复杂度都为$O(n2)$。  \n\n## 后续\n1.原理（长期）。  \n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Algorithm/insertion-sort.md","raw":"---\ntitle: 插入排序\ndate: 2021-10-09\ncategories: \n- Algorithm\ntags: \n- Algorithm\n- Math\n---\n# 插入排序  \n内容主要来源：  \n[https://oi-wiki.org/basic/radix-sort/](https://oi-wiki.org/basic/insertion-sort/)（OI Wiki）\n[https://www.runoob.com/w3cnote/radix-sort.html](https://www.runoob.com/w3cnote/insertion-sort.html)（菜鸟教程）  \n## 简介  \n插入排序（英语：Insertion sort）是一种简单直观的排序算法。它的工作原理为将待排列元素划分为“已排序”和“未排序”两部分，每次从“未排序的”元素中选择一个插入到“已排序的”元素中的正确位置。\n一个与插入排序相同的操作是打扑克牌时，从牌桌上抓一张牌，按牌面大小插到手牌后，再抓下一张牌。\n \n## 时空复杂度  \n插入排序的最优时间复杂度为$O(n)$，在数列几乎有序时效率很高。  \n插入排序的最坏时间复杂度和平均时间复杂度都为$O(n2)$。  \n\n## 后续\n1.原理（长期）。  \n\n\n\n\n\n\n\n\n\n\n","slug":"Algorithm/insertion-sort","published":1,"updated":"2023-02-19T09:23:10.694Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cleb7c83j000p1q96cjqx4wlr","content":"<h1 id=\"插入排序\"><a class=\"markdownIt-Anchor\" href=\"#插入排序\"></a> 插入排序</h1>\n<p>内容主要来源：<br>\n<a href=\"https://oi-wiki.org/basic/insertion-sort/\">https://oi-wiki.org/basic/radix-sort/</a>（OI Wiki）<br>\n<a href=\"https://www.runoob.com/w3cnote/insertion-sort.html\">https://www.runoob.com/w3cnote/radix-sort.html</a>（菜鸟教程）</p>\n<h2 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h2>\n<p>插入排序（英语：Insertion sort）是一种简单直观的排序算法。它的工作原理为将待排列元素划分为“已排序”和“未排序”两部分，每次从“未排序的”元素中选择一个插入到“已排序的”元素中的正确位置。<br>\n一个与插入排序相同的操作是打扑克牌时，从牌桌上抓一张牌，按牌面大小插到手牌后，再抓下一张牌。</p>\n<h2 id=\"时空复杂度\"><a class=\"markdownIt-Anchor\" href=\"#时空复杂度\"></a> 时空复杂度</h2>\n<p>插入排序的最优时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，在数列几乎有序时效率很高。<br>\n插入排序的最坏时间复杂度和平均时间复杂度都为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<h2 id=\"后续\"><a class=\"markdownIt-Anchor\" href=\"#后续\"></a> 后续</h2>\n<p>1.原理（长期）。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"插入排序\"><a class=\"markdownIt-Anchor\" href=\"#插入排序\"></a> 插入排序</h1>\n<p>内容主要来源：<br>\n<a href=\"https://oi-wiki.org/basic/insertion-sort/\">https://oi-wiki.org/basic/radix-sort/</a>（OI Wiki）<br>\n<a href=\"https://www.runoob.com/w3cnote/insertion-sort.html\">https://www.runoob.com/w3cnote/radix-sort.html</a>（菜鸟教程）</p>\n<h2 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h2>\n<p>插入排序（英语：Insertion sort）是一种简单直观的排序算法。它的工作原理为将待排列元素划分为“已排序”和“未排序”两部分，每次从“未排序的”元素中选择一个插入到“已排序的”元素中的正确位置。<br>\n一个与插入排序相同的操作是打扑克牌时，从牌桌上抓一张牌，按牌面大小插到手牌后，再抓下一张牌。</p>\n<h2 id=\"时空复杂度\"><a class=\"markdownIt-Anchor\" href=\"#时空复杂度\"></a> 时空复杂度</h2>\n<p>插入排序的最优时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，在数列几乎有序时效率很高。<br>\n插入排序的最坏时间复杂度和平均时间复杂度都为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<h2 id=\"后续\"><a class=\"markdownIt-Anchor\" href=\"#后续\"></a> 后续</h2>\n<p>1.原理（长期）。</p>\n"}],"PostAsset":[{"_id":"source/_posts/EdgeR(2)/1.png","slug":"1.png","post":"cleb7c83400011q96eqdue0mp","modified":0,"renderable":0},{"_id":"source/_posts/BuildBlog/blog1.png","slug":"blog1.png","post":"cleb7c83000001q96cj31e303","modified":0,"renderable":0},{"_id":"source/_posts/BuildBlog/blog10.png","slug":"blog10.png","post":"cleb7c83000001q96cj31e303","modified":0,"renderable":0},{"_id":"source/_posts/BuildBlog/blog11.png","slug":"blog11.png","post":"cleb7c83000001q96cj31e303","modified":0,"renderable":0},{"_id":"source/_posts/BuildBlog/blog12.png","slug":"blog12.png","post":"cleb7c83000001q96cj31e303","modified":0,"renderable":0},{"_id":"source/_posts/BuildBlog/blog13.png","slug":"blog13.png","post":"cleb7c83000001q96cj31e303","modified":0,"renderable":0},{"_id":"source/_posts/BuildBlog/blog2.png","slug":"blog2.png","post":"cleb7c83000001q96cj31e303","modified":0,"renderable":0},{"_id":"source/_posts/BuildBlog/blog3.jpeg","slug":"blog3.jpeg","post":"cleb7c83000001q96cj31e303","modified":0,"renderable":0},{"_id":"source/_posts/BuildBlog/blog4.png","slug":"blog4.png","post":"cleb7c83000001q96cj31e303","modified":0,"renderable":0},{"_id":"source/_posts/BuildBlog/blog5.png","slug":"blog5.png","post":"cleb7c83000001q96cj31e303","modified":0,"renderable":0},{"_id":"source/_posts/BuildBlog/blog6.png","slug":"blog6.png","post":"cleb7c83000001q96cj31e303","modified":0,"renderable":0},{"_id":"source/_posts/BuildBlog/blog7.png","slug":"blog7.png","post":"cleb7c83000001q96cj31e303","modified":0,"renderable":0},{"_id":"source/_posts/BuildBlog/blog8.png","slug":"blog8.png","post":"cleb7c83000001q96cj31e303","modified":0,"renderable":0},{"_id":"source/_posts/BuildBlog/blog9.png","slug":"blog9.png","post":"cleb7c83000001q96cj31e303","modified":0,"renderable":0},{"_id":"source/_posts/EdgeR/1.png","slug":"1.png","post":"cleb7c83800041q96b6h37j9e","modified":0,"renderable":0},{"_id":"source/_posts/EdgeR/2.png","slug":"2.png","post":"cleb7c83800041q96b6h37j9e","modified":0,"renderable":0},{"_id":"source/_posts/EdgeR/3.png","slug":"3.png","post":"cleb7c83800041q96b6h37j9e","modified":0,"renderable":0},{"_id":"source/_posts/EdgeR/4.png","slug":"4.png","post":"cleb7c83800041q96b6h37j9e","modified":0,"renderable":0},{"_id":"source/_posts/EdgeR/5.png","slug":"5.png","post":"cleb7c83800041q96b6h37j9e","modified":0,"renderable":0},{"_id":"source/_posts/EdgeR/6.png","slug":"6.png","post":"cleb7c83800041q96b6h37j9e","modified":0,"renderable":0},{"_id":"source/_posts/EdgeR/7.png","slug":"7.png","post":"cleb7c83800041q96b6h37j9e","modified":0,"renderable":0},{"_id":"source/_posts/EdgeR/8.png","slug":"8.png","post":"cleb7c83800041q96b6h37j9e","modified":0,"renderable":0},{"_id":"source/_posts/EdgeR/9.png","slug":"9.png","post":"cleb7c83800041q96b6h37j9e","modified":0,"renderable":0},{"_id":"source/_posts/PrincipleOfEdgeR/1.png","slug":"1.png","post":"cleb7c83a00061q962lzsgk89","modified":0,"renderable":0},{"_id":"source/_posts/PrincipleOfEdgeR/2.png","slug":"2.png","post":"cleb7c83a00061q962lzsgk89","modified":0,"renderable":0},{"_id":"source/_posts/InsertImageinHexo/insert.png","slug":"insert.png","post":"cleb7c83900051q96a6yc6ens","modified":0,"renderable":0},{"_id":"source/_posts/clusterProfiler/1.png","slug":"1.png","post":"cleb7c83b000a1q969o5u6nlv","modified":0,"renderable":0},{"_id":"source/_posts/clusterProfiler/2.png","slug":"2.png","post":"cleb7c83b000a1q969o5u6nlv","modified":0,"renderable":0},{"_id":"source/_posts/clusterProfiler/3.png","slug":"3.png","post":"cleb7c83b000a1q969o5u6nlv","modified":0,"renderable":0},{"_id":"source/_posts/clusterProfiler/4.png","slug":"4.png","post":"cleb7c83b000a1q969o5u6nlv","modified":0,"renderable":0},{"_id":"source/_posts/clusterProfiler/5.png","slug":"5.png","post":"cleb7c83b000a1q969o5u6nlv","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cleb7c83900051q96a6yc6ens","category_id":"cleb7c83600021q962z2h1y5w","_id":"cleb7c83d000d1q963l267kny"},{"post_id":"cleb7c83000001q96cj31e303","category_id":"cleb7c83600021q962z2h1y5w","_id":"cleb7c83g000h1q962jdy48x4"},{"post_id":"cleb7c83b000a1q969o5u6nlv","category_id":"cleb7c83a00071q96gyz70tsa","_id":"cleb7c83h000j1q9643ng2n70"},{"post_id":"cleb7c83400011q96eqdue0mp","category_id":"cleb7c83a00071q96gyz70tsa","_id":"cleb7c83j000n1q96emcp61n5"},{"post_id":"cleb7c83c000c1q96chigezyt","category_id":"cleb7c83600021q962z2h1y5w","_id":"cleb7c83k000q1q96go026qmp"},{"post_id":"cleb7c83800041q96b6h37j9e","category_id":"cleb7c83a00071q96gyz70tsa","_id":"cleb7c83k000u1q96877papmr"},{"post_id":"cleb7c83a00061q962lzsgk89","category_id":"cleb7c83a00071q96gyz70tsa","_id":"cleb7c83l000v1q961uafcull"},{"post_id":"cleb7c83f000g1q967rz9al2x","category_id":"cleb7c83k000r1q967k4b0v1w","_id":"cleb7c83l00101q96edf65luv"},{"post_id":"cleb7c83g000i1q964xrwhne7","category_id":"cleb7c83l000w1q961e7r9nta","_id":"cleb7c83n00151q967v5qdwes"},{"post_id":"cleb7c83i000m1q96gx92auh3","category_id":"cleb7c83l000w1q961e7r9nta","_id":"cleb7c83o00191q96fu7y3kog"},{"post_id":"cleb7c83j000p1q96cjqx4wlr","category_id":"cleb7c83l000w1q961e7r9nta","_id":"cleb7c83o001c1q967sarea45"}],"PostTag":[{"post_id":"cleb7c83900051q96a6yc6ens","tag_id":"cleb7c83700031q96hpx8fvlo","_id":"cleb7c83b00091q96h3wp0e7r"},{"post_id":"cleb7c83000001q96cj31e303","tag_id":"cleb7c83700031q96hpx8fvlo","_id":"cleb7c83c000b1q96gv2rf8ye"},{"post_id":"cleb7c83400011q96eqdue0mp","tag_id":"cleb7c83b00081q969clt3z9c","_id":"cleb7c83j000o1q96ctjoazxd"},{"post_id":"cleb7c83400011q96eqdue0mp","tag_id":"cleb7c83d000f1q96f7wt2o9d","_id":"cleb7c83k000s1q968x1685jj"},{"post_id":"cleb7c83800041q96b6h37j9e","tag_id":"cleb7c83b00081q969clt3z9c","_id":"cleb7c83l000y1q9663454vtu"},{"post_id":"cleb7c83800041q96b6h37j9e","tag_id":"cleb7c83d000f1q96f7wt2o9d","_id":"cleb7c83l000z1q962evzgem2"},{"post_id":"cleb7c83a00061q962lzsgk89","tag_id":"cleb7c83b00081q969clt3z9c","_id":"cleb7c83n00161q96gr2e33tv"},{"post_id":"cleb7c83a00061q962lzsgk89","tag_id":"cleb7c83d000f1q96f7wt2o9d","_id":"cleb7c83n00171q96e9djdi52"},{"post_id":"cleb7c83b000a1q969o5u6nlv","tag_id":"cleb7c83b00081q969clt3z9c","_id":"cleb7c83o001a1q961tuc2tvo"},{"post_id":"cleb7c83b000a1q969o5u6nlv","tag_id":"cleb7c83d000f1q96f7wt2o9d","_id":"cleb7c83o001b1q96feuk0354"},{"post_id":"cleb7c83c000c1q96chigezyt","tag_id":"cleb7c83700031q96hpx8fvlo","_id":"cleb7c83o001e1q96gfm3aswg"},{"post_id":"cleb7c83c000c1q96chigezyt","tag_id":"cleb7c83n00181q9651oi2jzp","_id":"cleb7c83o001f1q964wwo0sm8"},{"post_id":"cleb7c83f000g1q967rz9al2x","tag_id":"cleb7c83o001d1q964ae4cl4h","_id":"cleb7c83p001i1q963uf5bdeu"},{"post_id":"cleb7c83f000g1q967rz9al2x","tag_id":"cleb7c83o001g1q96bjhs01v5","_id":"cleb7c83p001j1q96f8g88fzz"},{"post_id":"cleb7c83g000i1q964xrwhne7","tag_id":"cleb7c83p001h1q962eoyf210","_id":"cleb7c83p001l1q963ofr8gaf"},{"post_id":"cleb7c83i000m1q96gx92auh3","tag_id":"cleb7c83p001h1q962eoyf210","_id":"cleb7c83q001o1q962d8dbyl4"},{"post_id":"cleb7c83i000m1q96gx92auh3","tag_id":"cleb7c83o001g1q96bjhs01v5","_id":"cleb7c83q001p1q965t7tey6o"},{"post_id":"cleb7c83j000p1q96cjqx4wlr","tag_id":"cleb7c83p001h1q962eoyf210","_id":"cleb7c83q001r1q96gtgugwvs"},{"post_id":"cleb7c83j000p1q96cjqx4wlr","tag_id":"cleb7c83o001g1q96bjhs01v5","_id":"cleb7c83q001s1q968g0zdvgz"}],"Tag":[{"name":"Blog","_id":"cleb7c83700031q96hpx8fvlo"},{"name":"RNA-Seq","_id":"cleb7c83b00081q969clt3z9c"},{"name":"DE-Analysis","_id":"cleb7c83d000f1q96f7wt2o9d"},{"name":"Web","_id":"cleb7c83n00181q9651oi2jzp"},{"name":"Deep Learning","_id":"cleb7c83o001d1q964ae4cl4h"},{"name":"Math","_id":"cleb7c83o001g1q96bjhs01v5"},{"name":"Algorithm","_id":"cleb7c83p001h1q962eoyf210"}]}}